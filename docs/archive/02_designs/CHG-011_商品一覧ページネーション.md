# CHG-011: 商品一覧ページネーション（設計）

要件: `docs/01_requirements/CHG-011_商品一覧ページネーション.md`
作成日: 2026-02-17

---

## 1. 設計方針

フロントエンドのみの変更。バックエンドAPIは既にページング対応済み（`GET /api/item` — `page`, `limit` パラメータ）。

現在 `ProductContext` はアプリ起動時に全商品を一括取得してグローバルに保持しているが、ページネーションでは「商品一覧画面がアクティブなページの商品だけを取得する」必要がある。そのため、商品一覧画面ではContextを経由せず、`ItemListPage` コンポーネント内で直接APIを呼び出す方式に変更する。

`ProductContext` は引き続きTOP画面のおすすめ商品や管理画面で使用するため、既存の仕組みはそのまま維持する。

URL クエリパラメータとの連動には React Router v7 の `useSearchParams` を使用する（プロジェクト内で初使用だが、既に `useParams`, `useNavigate`, `useLocation` が利用されており、同一ライブラリの標準APIのため自然な拡張）。

---

## 2. フロントエンド実装

### 2-1. 変更: `ItemListPage.tsx`（大幅変更）

`ProductContext` 依存から、コンポーネント内で直接APIを呼び出す方式に変更する。

**変更前**:

```tsx
import ProductCard from '../components/ProductCard'
import { useProducts } from '../contexts/ProductContext'

export default function ItemListPage() {
  const { getPublishedProducts } = useProducts()
  const publishedProducts = getPublishedProducts()

  return (
    <div className="mx-auto max-w-7xl px-6 py-24">
      <h1 className="mb-12 font-serif text-3xl text-zinc-900">すべての商品</h1>
      <div className="grid gap-x-6 gap-y-12 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        {publishedProducts.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  )
}
```

**変更後**:

```tsx
import { useState, useEffect } from 'react'
import { useSearchParams } from 'react-router'
import ProductCard from '../components/ProductCard'
import Pagination from '../components/Pagination'
import * as api from '../lib/api'
import type { Product } from '../types/api'

const ITEMS_PER_PAGE = 12

export default function ItemListPage() {
  const [searchParams, setSearchParams] = useSearchParams()
  const [products, setProducts] = useState<Product[]>([])
  const [total, setTotal] = useState(0)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // URLからページ番号を取得（不正値は1にフォールバック）
  const currentPage = Math.max(1, parseInt(searchParams.get('page') || '1') || 1)

  const totalPages = Math.ceil(total / ITEMS_PER_PAGE)

  useEffect(() => {
    const fetchProducts = async () => {
      setLoading(true)
      setError(null)
      try {
        const response = await api.getItems(currentPage, ITEMS_PER_PAGE)
        if (response.success && response.data) {
          setProducts(response.data.items)
          setTotal(response.data.total)
        } else {
          setError('商品の取得に失敗しました')
        }
      } catch {
        setError('商品の取得中にエラーが発生しました')
      } finally {
        setLoading(false)
      }
    }
    fetchProducts()
  }, [currentPage])

  const handlePageChange = (page: number) => {
    if (page === 1) {
      setSearchParams({})
    } else {
      setSearchParams({ page: String(page) })
    }
    window.scrollTo({ top: 0, behavior: 'smooth' })
  }

  if (loading) {
    return (
      <div className="mx-auto max-w-7xl px-6 py-24">
        <h1 className="mb-12 font-serif text-3xl text-zinc-900">すべての商品</h1>
        <p className="text-sm text-zinc-500">読み込み中...</p>
      </div>
    )
  }

  if (error) {
    return (
      <div className="mx-auto max-w-7xl px-6 py-24">
        <h1 className="mb-12 font-serif text-3xl text-zinc-900">すべての商品</h1>
        <p className="text-sm text-zinc-500">{error}</p>
      </div>
    )
  }

  return (
    <div className="mx-auto max-w-7xl px-6 py-24">
      <h1 className="mb-12 font-serif text-3xl text-zinc-900">すべての商品</h1>
      <div className="grid gap-x-6 gap-y-12 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        {products.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
      {totalPages > 1 && (
        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={handlePageChange}
        />
      )}
    </div>
  )
}
```

**設計判断**:
- `ProductContext.getPublishedProducts()` は `isPublished` でフィルタしていたが、バックエンドAPIが公開商品のみを返すため（BFF経由の `GET /api/products`）、フロントエンド側のフィルタは不要
- ページ1の場合は `?page=1` を付けずクリーンなURLを維持する
- ページ切り替え時にスクロールをトップに戻す

### 2-2. 新規: `Pagination.tsx` コンポーネント

`frontend/src/components/Pagination.tsx` を新規作成。

デザインシステムに準拠し、エディトリアルデザインのトーンに合わせたミニマルなページネーションUI。

```tsx
interface PaginationProps {
  currentPage: number
  totalPages: number
  onPageChange: (page: number) => void
}

export default function Pagination({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) {
  // 表示するページ番号を生成（現在ページの前後を含む）
  const getPageNumbers = (): (number | '...')[] => {
    const pages: (number | '...')[] = []

    if (totalPages <= 7) {
      // 7ページ以下: 全ページ表示
      for (let i = 1; i <= totalPages; i++) pages.push(i)
    } else {
      // 8ページ以上: 先頭・末尾・現在ページ周辺を表示
      pages.push(1)
      if (currentPage > 3) pages.push('...')

      const start = Math.max(2, currentPage - 1)
      const end = Math.min(totalPages - 1, currentPage + 1)
      for (let i = start; i <= end; i++) pages.push(i)

      if (currentPage < totalPages - 2) pages.push('...')
      pages.push(totalPages)
    }

    return pages
  }

  return (
    <nav className="mt-16 flex items-center justify-center gap-1" aria-label="ページネーション">
      {/* 前へ */}
      <button
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage <= 1}
        className="px-3 py-2 text-xs uppercase tracking-[0.2em] text-zinc-500 transition-colors hover:text-zinc-900 disabled:text-stone-300 disabled:cursor-not-allowed"
      >
        Prev
      </button>

      {/* ページ番号 */}
      {getPageNumbers().map((page, index) =>
        page === '...' ? (
          <span key={`ellipsis-${index}`} className="px-2 py-2 text-xs text-zinc-400">
            ...
          </span>
        ) : (
          <button
            key={page}
            onClick={() => onPageChange(page)}
            className={`min-w-[2.5rem] px-2 py-2 text-xs transition-colors ${
              page === currentPage
                ? 'bg-zinc-900 text-white'
                : 'text-zinc-500 hover:text-zinc-900'
            }`}
          >
            {page}
          </button>
        )
      )}

      {/* 次へ */}
      <button
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage >= totalPages}
        className="px-3 py-2 text-xs uppercase tracking-[0.2em] text-zinc-500 transition-colors hover:text-zinc-900 disabled:text-stone-300 disabled:cursor-not-allowed"
      >
        Next
      </button>
    </nav>
  )
}
```

**デザインシステムとの整合性**:

| 要素 | スタイル | 根拠 |
|------|---------|------|
| Prev/Next ラベル | `text-xs uppercase tracking-[0.2em]` | ボタン・ナビのタイポグラフィ規約 |
| 現在ページ | `bg-zinc-900 text-white` | プライマリボタンのカラー |
| 非現在ページ | `text-zinc-500 hover:text-zinc-900` | リンクのホバーパターン |
| 無効状態 | `text-stone-300 disabled:cursor-not-allowed` | 無効ボタンのトーン |
| 間隔 | `mt-16`（グリッドとの間） | 中セクション間スペーシング |
| 角丸・影 | なし | 商品カードと同じフラットデザイン |

---

## 3. 処理フロー

```
商品一覧画面表示
  → URLの ?page パラメータを読み取り（デフォルト: 1）
  → getItems(page, 12) をAPI呼び出し
  → レスポンスの items を表示、total からページ数を算出
  → totalPages > 1 の場合のみ Pagination を表示

ページ切り替え
  → Pagination の onPageChange 発火
  → setSearchParams で URL を更新（?page=N）
  → useEffect が currentPage の変更を検知
  → getItems(newPage, 12) を再呼び出し
  → 商品リスト更新、スクロールをトップへ

ブラウザの戻る/進む
  → URL変更を useSearchParams が検知
  → currentPage が再計算される
  → useEffect が発火し、該当ページの商品を取得
```

---

## 4. 既存パターンとの整合性

| 観点 | 既存パターン | CHG-011 |
|------|-------------|---------|
| データ取得 | `ProductContext` でグローバル管理 | ページ内で直接API呼び出し |
| ローディング | `ProductContext.loading` | ページ内ローカルstate |
| エラー処理 | `ProductContext.error` | ページ内ローカルstate |
| URL状態管理 | `useParams`（パスパラメータ） | `useSearchParams`（クエリパラメータ） |
| API呼び出し | `api.ts` の関数を使用 | 同じ（`api.getItems(page, limit)`） |

**`ProductContext` との共存**: `ProductContext` は TOP画面のおすすめ商品取得（全件から先頭3件）と管理画面の商品管理で引き続き使用される。商品一覧画面のみがContextを使わなくなる。

---

## 5. テスト観点

- 初回表示: 1ページ目の商品が12件表示される
- ページ切り替え: 「Next」クリックで2ページ目の商品が表示される
- URL連動: `/item?page=2` に直接アクセスで2ページ目が表示される
- ブラウザ戻る: 2ページ目 → 1ページ目に戻れる
- 不正なページ: `/item?page=0`, `/item?page=abc`, `/item?page=999` で1ページ目を表示
- 1ページ以下: 商品が12件以下の場合、ページネーションUIが非表示
- ローディング: ページ切り替え中に「読み込み中...」が表示される
- 既存動線: 商品カードクリック → 商品詳細画面への遷移が正常に動作

---

## 6. 影響範囲

### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `frontend/src/pages/ItemListPage.tsx` | ページネーション対応に全面書き換え |
| `frontend/src/components/Pagination.tsx` | **新規作成** |

### 影響なし

| ファイル | 理由 |
|---------|------|
| `frontend/src/contexts/ProductContext.tsx` | 変更不要（TOP画面・管理画面で引き続き使用） |
| `frontend/src/lib/api.ts` | 変更不要（`getItems(page, limit)` は既に対応済み） |
| `frontend/src/types/api.ts` | 変更不要（`ProductListResponse` は既に定義済み） |
| バックエンド全般 | 変更不要（API既にページング対応済み） |
| BFF全般 | 変更不要（プロキシ透過） |
