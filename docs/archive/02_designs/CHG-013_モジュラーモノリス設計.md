# CHG-013: モジュラーモノリス設計 - 技術設計

要件: `docs/01_requirements/CHG-013_モジュラーモノリス設計.md`
作成日: 2026-02-18

---

## 1. 設計方針

### 1.1 基本原則

- **デプロイメント**: 単一のJARファイルとして動作するモノリスアプリケーション
- **内部構造**: 明確なモジュール境界でドメインを分離（モジュラーモノリス）
- **依存方向**: 一方向のみ許可、循環依存を禁止
- **境界制御**: ArchUnitによるテスト駆動の制約
- **連携方式**: 同期（Service Interface）+ 非同期（Spring Application Events）
- **データベース**: 単一DB、テーブルはモジュール責務で分離、クロスモジュールJOIN非推奨

### 1.2 モジュール分割方針

ECドメインを以下7モジュールに分割:

| モジュール | 責務 | 主要エンティティ |
|-----------|------|----------------|
| **product** | 商品マスタ管理 | Product |
| **inventory** | 在庫管理・引当 | StockReservation, InventoryAdjustment |
| **purchase** | 購買（カート・注文） | Cart, CartItem, Order, OrderItem |
| **payment** | 決済処理（Phase 2） | （未実装） |
| **customer** | 会員・認証 | User, AuthToken |
| **backoffice** | 管理画面・権限 | BoUser, BoAuthToken |
| **shared** | 共通コンポーネント | 例外、DTO、Enum、OperationHistory |

### 1.3 優先境界の明確化

最重要境界（要件より）:
- **purchase / payment / inventory**: 購買から決済・在庫引当までの主要フロー
- **checkout**: これらのモジュールを調整するユースケース（purchase モジュール内に配置）

---

## 2. パッケージ構造

### 2.1 全体構造

```
com.example.aiec/
├── modules/
│   ├── product/          # 商品マスタ管理モジュール
│   ├── inventory/        # 在庫管理モジュール
│   ├── purchase/         # 購買モジュール（カート・注文）
│   ├── payment/          # 決済モジュール（Phase 2）
│   ├── customer/         # 会員モジュール
│   ├── backoffice/       # 管理画面モジュール
│   └── shared/           # 共通モジュール
└── config/               # アプリケーション設定（グローバル）
```

### 2.2 モジュール内部構造（標準レイアウト）

各モジュールは以下の3層構造を採用:

```
modules/<module-name>/
├── domain/                  # ドメイン層
│   ├── entity/              # エンティティ
│   ├── repository/          # リポジトリインターフェース
│   └── service/             # ドメインサービス
├── application/             # アプリケーション層
│   ├── usecase/             # ユースケース（複合処理）
│   └── port/                # モジュール公開インターフェース（他モジュールから呼び出し可能）
├── adapter/                 # アダプター層
│   ├── rest/                # RESTコントローラ
│   └── dto/                 # DTO（リクエスト・レスポンス）
└── <ModuleName>ModuleConfig.java  # モジュール設定クラス
```

**レイヤー責務**:

| レイヤー | 責務 | 公開範囲 |
|---------|------|---------|
| **domain** | ビジネスロジック、エンティティ、リポジトリ | モジュール内部のみ |
| **application.usecase** | 複合処理、トランザクション境界 | モジュール内部のみ |
| **application.port** | モジュール公開API（Service Interface） | **他モジュールから参照可能** |
| **adapter** | 外部I/O（REST、DTO） | モジュール内部のみ |

### 2.3 purchase モジュールの内部構造

purchase モジュールは複数のサブドメイン（cart / order / checkout）を含むため、特殊な構造を採用:

```
modules/purchase/
├── cart/                     # カートサブドメイン
│   ├── entity/               # Cart, CartItem
│   ├── repository/           # CartRepository, CartItemRepository
│   └── service/              # CartService
├── order/                    # 注文サブドメイン
│   ├── entity/               # Order, OrderItem
│   ├── repository/           # OrderRepository, OrderItemRepository
│   └── service/              # OrderService
├── checkout/                 # チェックアウトユースケース
│   └── usecase/              # CheckoutUseCase（cart → order 変換）
├── application/
│   └── port/                 # 公開API（他モジュールから参照可能）
├── adapter/
│   ├── rest/                 # RESTコントローラ
│   └── dto/                  # DTO
└── PurchaseModuleConfig.java
```

**サブドメイン分割の理由**:
- cart: 一時的なデータ、セッション管理
- order: 永続的なデータ、注文履歴
- checkout: 両者を調整するユースケース

---

## 3. モジュール間の連携方式

### 3.1 同期連携（Service Interface）

他モジュールの機能を呼び出す際は、`application.port` パッケージの公開インターフェースを使用。

**例: purchase モジュールが inventory モジュールの在庫確認を呼び出す**

```java
// inventory モジュール: 公開インターフェース
package com.example.aiec.modules.inventory.application.port;

public interface InventoryQueryPort {
    int getAvailableStock(Long productId);
}

// inventory モジュール: 実装（内部）
package com.example.aiec.modules.inventory.application.usecase;

@Service
class InventoryQueryService implements InventoryQueryPort {
    @Override
    public int getAvailableStock(Long productId) {
        // 実装...
    }
}
```

```java
// purchase モジュール: inventory モジュールの Port を参照
package com.example.aiec.modules.purchase.checkout.usecase;

@Service
public class CheckoutUseCase {
    private final InventoryQueryPort inventoryQuery;  // Port 経由で依存

    public CheckoutUseCase(InventoryQueryPort inventoryQuery) {
        this.inventoryQuery = inventoryQuery;
    }

    public void checkout(Long productId, int quantity) {
        int available = inventoryQuery.getAvailableStock(productId);  // 同期呼び出し
        // ...
    }
}
```

### 3.2 非同期連携（Spring Application Events）

**重要**: 業務ロジックの主要フロー（注文確定→在庫引当など）は**同期処理**で実装します。非同期イベントは以下のような副作用的な処理にのみ使用します:

- **監査ログ記録**: 本処理失敗時もログを残すため別トランザクション（REQUIRES_NEW）で実行
- **通知系**（Phase 2以降）: メール送信、Slack通知など、失敗しても本処理に影響がない処理
- **集計・分析**（Phase 2以降）: 売上集計、ランキング更新など、リアルタイム性が不要な処理
- **外部システム連携**（Phase 2以降）: 倉庫システムへの出荷依頼など、疎結合が望ましい処理

**例: 監査ログ記録（Phase 1で実装）**

```java
// shared モジュール: イベント定義
package com.example.aiec.modules.shared.event;

public record OperationPerformedEvent(
    String operationType,
    String performedBy,
    String requestPath,
    String details
) {}
```

```java
// purchase モジュール: イベント発行
package com.example.aiec.modules.purchase.checkout.usecase;

@Service
public class CheckoutUseCase {
    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public void checkout(CheckoutRequest request) {
        // 注文処理（同期）...
        Order order = createAndSaveOrder(request);

        // 監査ログはイベントで非同期記録
        eventPublisher.publishEvent(new OperationPerformedEvent(
            "ORDER_CHECKOUT",
            request.getUserId().toString(),
            "/api/orders",
            "orderId=" + order.getId()
        ));
    }
}
```

```java
// backoffice モジュール: イベント受信
package com.example.aiec.modules.backoffice.application.usecase;

@Service
public class OperationHistoryEventHandler {

    @EventListener
    @Transactional(propagation = Propagation.REQUIRES_NEW)  // 別トランザクション
    public void handleOperationPerformed(OperationPerformedEvent event) {
        // 監査ログ記録（本処理が失敗してもログは残る）
        operationHistoryRepository.save(new OperationHistory(...));
    }
}
```

### 3.3 連携方針の選択ガイド

| ケース | 連携方式 | 理由 |
|--------|---------|------|
| **注文確定→在庫引当** | 同期（Port） | データ整合性必須・同一トランザクション |
| **商品情報取得** | 同期（Port） | リアルタイム応答必須 |
| **在庫確認** | 同期（Port） | リアルタイム応答必須 |
| **監査ログ記録** | 非同期（Event） | 本処理失敗時もログ残す（REQUIRES_NEW） |
| **メール送信**（Phase 2） | 非同期（Event） | 失敗しても本処理に影響なし |
| **集計・分析**（Phase 2） | 非同期（Event） | リアルタイム性不要 |
| **外部システム連携**（Phase 2） | 非同期（Event） | 疎結合が望ましい |

**注意**: キャッシュ更新はCore API内のイベントではなく、BFF層（NestJS + Redis）で実装します。

---

## 4. 既存コードの移行計画

### 4.1 移行方針

全面リファクタリングを段階的に実施:

| Phase | 対象 | 作業内容 |
|-------|------|---------|
| **Phase 1** | パッケージ構造 | 横割り構造→モジュール構造へファイル移動・リネーム |
| **Phase 2** | Port抽出 | モジュール公開API（Port）の定義・実装分離 |
| **Phase 3** | ArchUnit導入 | 境界違反を検出するテストコード追加 |
| **Phase 4** | 監査ログイベント | OperationPerformedEvent実装（REQUIRES_NEW） |

**注**: Phase 1〜4は業務ロジックを同期処理で実装。通知系・集計系イベントはPhase 5以降で追加予定。

### 4.2 Phase 1: パッケージ移動マッピング

#### product モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/Product.java` | `modules/product/domain/entity/Product.java` |
| `repository/ProductRepository.java` | `modules/product/domain/repository/ProductRepository.java` |
| `service/ProductService.java` | `modules/product/domain/service/ProductService.java` |
| `controller/ItemController.java` | `modules/product/adapter/rest/ProductController.java` |
| `dto/ProductDto.java`, `ProductListResponse.java` | `modules/product/adapter/dto/` |

#### inventory モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/StockReservation.java`, `InventoryAdjustment.java` | `modules/inventory/domain/entity/` |
| `repository/StockReservationRepository.java`, `InventoryAdjustmentRepository.java` | `modules/inventory/domain/repository/` |
| `service/InventoryService.java` | `modules/inventory/domain/service/InventoryService.java` |
| `controller/InventoryController.java`, `BoAdminInventoryController.java` | `modules/inventory/adapter/rest/` |
| `dto/InventoryStatusDto.java`, `StockShortageDetail.java` | `modules/inventory/adapter/dto/` |

#### purchase モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/Cart.java`, `CartItem.java` | `modules/purchase/cart/entity/` |
| `entity/Order.java`, `OrderItem.java` | `modules/purchase/order/entity/` |
| `repository/CartRepository.java`, `CartItemRepository.java` | `modules/purchase/cart/repository/` |
| `repository/OrderRepository.java`, `OrderItemRepository.java` | `modules/purchase/order/repository/` |
| `service/CartService.java` | `modules/purchase/cart/service/` |
| `service/OrderService.java` | `modules/purchase/order/service/` |
| `controller/OrderController.java` | `modules/purchase/adapter/rest/OrderController.java` |
| `dto/CartDto.java`, `CartItemDto.java`, `OrderDto.java`, `OrderItemDto.java` | `modules/purchase/adapter/dto/` |

**Note**: purchase モジュール内は cart / order / checkout のサブパッケージで整理

#### customer モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/User.java`, `AuthToken.java` | `modules/customer/domain/entity/` |
| `repository/UserRepository.java`, `AuthTokenRepository.java` | `modules/customer/domain/repository/` |
| `service/UserService.java`, `AuthService.java` | `modules/customer/domain/service/` |
| `controller/AuthController.java` | `modules/customer/adapter/rest/AuthController.java` |
| `dto/UserDto.java`, `AuthResponse.java`, `LoginRequest.java`, `RegisterRequest.java` | `modules/customer/adapter/dto/` |

#### backoffice モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/BoUser.java`, `BoAuthToken.java` | `modules/backoffice/domain/entity/` |
| `repository/BoUserRepository.java`, `BoAuthTokenRepository.java` | `modules/backoffice/domain/repository/` |
| `service/BoUserService.java`, `BoAuthService.java` | `modules/backoffice/domain/service/` |
| `controller/BoAuthController.java`, `BoAdminController.java`, `BoAdminBoUsersController.java` | `modules/backoffice/adapter/rest/` |
| `dto/BoUserDto.java` | `modules/backoffice/adapter/dto/` |

#### shared モジュール

| 移動元 | 移動先 |
|--------|--------|
| `entity/ActorType.java`, `PermissionLevel.java` | `modules/shared/domain/model/` |
| `entity/OperationHistory.java` | `modules/shared/domain/entity/OperationHistory.java` |
| `repository/OperationHistoryRepository.java` | `modules/shared/domain/repository/OperationHistoryRepository.java` |
| `service/OperationHistoryService.java` | `modules/shared/domain/service/OperationHistoryService.java` |
| `exception/*` | `modules/shared/exception/` |
| `dto/ApiResponse.java` | `modules/shared/dto/ApiResponse.java` |

**Note**: OperationHistory は全モジュールから記録されるため shared に配置

### 4.3 Phase 2: Port抽出例

既存のServiceクラスから公開APIを抽出:

**変更前（横割り構造）**:
```java
// service/InventoryService.java
@Service
public class InventoryService {
    public int getAvailableStock(Long productId) { /* ... */ }
    public void reserveStock(Long productId, int quantity) { /* ... */ }
    // 内部用メソッドも混在...
}
```

**変更後（モジュラー構造）**:
```java
// modules/inventory/application/port/InventoryQueryPort.java（公開API）
public interface InventoryQueryPort {
    int getAvailableStock(Long productId);
}

// modules/inventory/application/port/InventoryCommandPort.java（公開API）
public interface InventoryCommandPort {
    void reserveStock(Long productId, int quantity);
}

// modules/inventory/application/usecase/InventoryUseCase.java（実装・内部のみ）
@Service
class InventoryUseCase implements InventoryQueryPort, InventoryCommandPort {
    @Override
    public int getAvailableStock(Long productId) { /* ... */ }

    @Override
    public void reserveStock(Long productId, int quantity) { /* ... */ }

    // 内部用メソッドはprivate
    private void internalMethod() { /* ... */ }
}
```

---

## 5. ArchUnitによる境界制御

### 5.1 ArchUnit導入

**依存関係**:
```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.tngtech.archunit</groupId>
    <artifactId>archunit-junit5</artifactId>
    <version>1.2.1</version>
    <scope>test</scope>
</dependency>
```

### 5.2 アーキテクチャルール

**`backend/src/test/java/com/example/aiec/architecture/ModularMonolithArchitectureTest.java`**:

```java
package com.example.aiec.architecture;

import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.library.Architectures;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static com.tngtech.archunit.library.Architectures.layeredArchitecture;

public class ModularMonolithArchitectureTest {

    private static JavaClasses classes;

    @BeforeAll
    public static void setUp() {
        classes = new ClassFileImporter().importPackages("com.example.aiec");
    }

    /**
     * ルール1: モジュール間の依存方向を制御（循環禁止）
     */
    @Test
    void moduleShouldNotDependOnEachOtherExceptThroughPorts() {
        Architectures.onionArchitecture()
            .domainModels("..modules.(*).domain..")
            .applicationServices("..modules.(*).application..")
            .adapter("rest", "..modules.(*).adapter.rest..")
            .adapter("dto", "..modules.(*).adapter.dto..")
            .check(classes);
    }

    /**
     * ルール2: domain層は他モジュールのdomainを直接参照してはいけない
     */
    @Test
    void domainLayerShouldNotAccessOtherModuleDomain() {
        noClasses()
            .that().resideInAPackage("..modules.(*).domain..")
            .should().accessClassesThat().resideInAPackage("..modules.(!$1).domain..")
            .check(classes);
    }

    /**
     * ルール3: 他モジュールはapplication.portのみ参照可能
     */
    @Test
    void otherModulesShouldOnlyAccessThroughPort() {
        classes()
            .that().resideInAPackage("..modules.(*)..")
            .and().resideOutsideOfPackage("..modules.(*).application.port..")
            .should().onlyAccessClassesThat().resideInAnyPackage(
                "..modules.$1..",           // 自モジュール
                "..modules.shared..",        // shared
                "..modules.(*).application.port..",  // 他モジュールのPort
                "java..",
                "org.springframework.."
            )
            .check(classes);
    }

    /**
     * ルール4: adapter層はdomain層に依存してはいけない（domainはportを経由）
     */
    @Test
    void adapterShouldNotAccessDomainDirectly() {
        noClasses()
            .that().resideInAPackage("..modules.(*).adapter..")
            .should().accessClassesThat().resideInAPackage("..modules.$1.domain..")
            .check(classes);
    }
}
```

---

## 6. データベース設計方針

### 6.1 テーブルのモジュール責務分離

単一DBを使用するが、テーブルはモジュール責務で分離:

| モジュール | 所有テーブル |
|-----------|-------------|
| **catalog** | `products` |
| **inventory** | `stock_reservations`, `inventory_adjustments` |
| **order** | `orders`, `order_items`, `carts`, `cart_items` |
| **customer** | `users`, `auth_tokens` |
| **backoffice** | `bo_users`, `bo_auth_tokens`, `operation_histories` |

### 6.2 クロスモジュール参照の制約

**禁止事項**:
- ❌ クロスモジュールJOINを前提とした設計
- ❌ 他モジュールのRepositoryを直接呼び出し
- ❌ JPA の `@ManyToOne` / `@OneToMany` でのモジュール跨ぎ関連

**許可事項**:
- ✅ ID参照（Long型のproductId等を保持）
- ✅ Portインターフェース経由で他モジュールのデータ取得
- ✅ イベント経由でのデータ同期

**例: order モジュールが catalog モジュールの商品情報を取得**

```java
// ❌ BAD: 直接JOIN
@Entity
public class OrderItem {
    @ManyToOne
    private Product product;  // 他モジュールのエンティティを直接参照
}

// ✅ GOOD: ID参照 + Port経由で取得
@Entity
public class OrderItem {
    private Long productId;  // ID参照のみ
}

// UseCase内でPort経由で商品情報を取得
public class OrderDetailUseCase {
    private final ProductQueryPort productQuery;

    public OrderDetailDto getOrderDetail(Long orderId) {
        Order order = orderRepository.findById(orderId);
        List<ProductDto> products = order.getItems().stream()
            .map(item -> productQuery.getProduct(item.getProductId()))  // Port経由
            .toList();
        // ...
    }
}
```

---

## 7. イベント設計

### 7.1 イベント適用方針

**Phase 1（モジュラーモノリス移行）**: 監査ログ記録のみ
**Phase 2以降**: 通知系、集計・分析系を追加

### 7.2 ドメインイベント定義

**`modules/shared/event/DomainEvent.java`**:

```java
package com.example.aiec.modules.shared.event;

import java.time.Instant;

public interface DomainEvent {
    Instant occurredAt();
}
```

**Phase 1 で実装するイベント**:

| イベント名 | 発行モジュール | 購読モジュール | タイミング | 用途 |
|-----------|---------------|--------------|----------|------|
| `OperationPerformedEvent` | 各モジュール | backoffice | 主要操作時 | 監査ログ記録 |

**Phase 2 以降で実装予定のイベント**:

| イベント名 | 発行モジュール | 購読モジュール | タイミング | 用途 |
|-----------|---------------|--------------|----------|------|
| `OrderCreatedEvent` | order | - | 注文作成後 | メール送信、通知 |
| `OrderStatusChangedEvent` | order | - | 注文状態変更後 | メール送信、通知 |
| `ProductPublishedEvent` | catalog | - | 商品公開時 | キャッシュ更新（BFF）、通知 |
| `ProductStockChangedEvent` | inventory | - | 在庫変更時 | キャッシュ更新（BFF） |

### 7.3 イベント実装例（Phase 1）

**`modules/shared/event/OperationPerformedEvent.java`**:

```java
package com.example.aiec.modules.shared.event;

import java.time.Instant;

public record OperationPerformedEvent(
    String operationType,
    String performedBy,
    String requestPath,
    String details,
    Instant occurredAt
) implements DomainEvent {
    public OperationPerformedEvent(
        String operationType,
        String performedBy,
        String requestPath,
        String details
    ) {
        this(operationType, performedBy, requestPath, details, Instant.now());
    }
}
```

---

## 8. 処理フロー例（checkout）

checkout は purchase / inventory / product の3モジュールを調整するユースケース。**全て同期処理**で実装します。

```
[User] → POST /api/orders
         ↓
    [Purchase Module: OrderController]
         ↓
    [Purchase Module: CheckoutUseCase]
    @Transactional  # 同一トランザクション
         │
         ├─→ ProductQueryPort.getProduct(productId)
         │   # 同期: 商品情報取得・価格確認
         │   # product モジュールの Port 経由
         │
         ├─→ InventoryQueryPort.getAvailableStock(productId)
         │   # 同期: 在庫確認
         │   # inventory モジュールの Port 経由
         │   # 在庫不足なら例外スロー → ロールバック
         │
         ├─→ Order order = createOrder(...)
         │   # 注文エンティティ作成
         │
         ├─→ InventoryCommandPort.reserveStock(productId, quantity)
         │   # 同期: 在庫引当（本引当）
         │   # inventory モジュールの Port 経由
         │   # 失敗時は例外スロー → ロールバック
         │
         ├─→ orderRepository.save(order)
         │   # 注文確定
         │
         └─→ publish(OperationPerformedEvent(...))
             # 監査ログ記録イベント発行（非同期・別トランザクション）
             # 本処理が失敗してもログは残る
```

**ポイント**:
- 注文作成→在庫引当→注文保存は**同一トランザクション**で実行
- 在庫引当失敗時は例外がスローされ、注文もロールバック
- データ整合性が保証される
- 監査ログのみ非同期イベントで記録（REQUIRES_NEW）

---

## 9. 既存パターンとの整合性

| 項目 | 既存パターン（横割り） | モジュラーモノリス | 変更理由 |
|------|-------------------|------------------|---------|
| **構造** | controller / service / repository / entity | modules/<module>/domain/application/adapter | 境界明確化・分割可能性 |
| **依存** | 全サービスが相互参照可能 | Port経由のみ参照可能 | 循環依存防止 |
| **トランザクション** | @Transactional 自由配置 | UseCaseでトランザクション境界 | 責務明確化 |
| **DTO変換** | fromEntity() 静的メソッド | 継続（adapter層で実施） | 既存パターン維持 |
| **例外** | ResourceNotFoundException 等 | 継続（sharedに配置） | 既存パターン維持 |

---

## 10. テスト観点

| 観点 | テスト内容 |
|------|----------|
| **ArchUnit** | モジュール境界違反の検出 |
| **単体テスト** | 各モジュールのdomain/application層のロジック |
| **統合テスト** | Port経由のモジュール間連携 |
| **イベントテスト** | イベント発行・受信の動作確認 |
| **E2Eテスト** | checkout等の複合フロー |

---

## 11. 影響範囲

### 11.1 変更対象ファイル

**全ファイル移動**: `backend/src/main/java/com/example/aiec/` 配下の全Javaファイル

| 対象 | 変更内容 |
|------|---------|
| **エンティティ** | `entity/` → `modules/<module>/domain/entity/` に移動 |
| **リポジトリ** | `repository/` → `modules/<module>/domain/repository/` に移動 |
| **サービス** | `service/` → `modules/<module>/domain/service/` に移動、Port抽出 |
| **コントローラ** | `controller/` → `modules/<module>/adapter/rest/` に移動 |
| **DTO** | `dto/` → `modules/<module>/adapter/dto/` または `modules/shared/dto/` に移動 |
| **例外** | `exception/` → `modules/shared/exception/` に移動 |
| **設定** | `config/` → 継続（グローバル設定）、モジュール別設定は各モジュールに追加 |

### 11.2 新規作成ファイル

| ファイル | 目的 |
|---------|------|
| **各モジュールのModuleConfig.java** | Spring設定クラス（@Configuration） |
| **application/port/*.java** | モジュール公開インターフェース |
| **application/usecase/*.java** | 複合処理・トランザクション境界 |
| **shared/event/*.java** | ドメインイベント定義 |
| **architecture/ModularMonolithArchitectureTest.java** | ArchUnitテスト |

### 11.3 影響なし

| 対象 | 理由 |
|------|------|
| **フロントエンド** | API仕様は変わらない（BFF経由のエンドポイントは同一） |
| **BFF** | Core APIの内部構造変更のため影響なし |
| **データベーススキーマ** | テーブル構造は変更なし |

---

## 12. 段階的移行ロードマップ

| Phase | 期間目安 | 作業内容 | 検証方法 |
|-------|---------|---------|---------|
| **Phase 1** | 2週間 | パッケージ移動・リネーム | 既存テスト全パス |
| **Phase 2** | 1週間 | Port抽出・UseCase作成 | 統合テスト実施 |
| **Phase 3** | 3日 | ArchUnit導入・テスト作成 | 境界違反0件 |
| **Phase 4** | 3日 | 監査ログイベント実装（OperationPerformedEvent） | E2Eテスト実施 |
| **Phase 5以降** | 未定 | 通知系・集計系イベント追加（メール送信等） | 機能追加時に実施 |

---

## 13. リスクと対策

| リスク | 対策 |
|--------|------|
| 全面リファクタリングによる不具合混入 | Phase 1完了時点で既存テスト全パス確認、段階的リリース |
| ArchUnit違反の大量発生 | Phase 3でルール厳格化前に段階的に修正、警告レベルから開始 |
| トランザクション境界の誤り | UseCaseで明示的に`@Transactional`指定、統合テストで検証 |
| イベント順序依存の問題 | イベントハンドラは冪等性を保証、リトライ可能な設計 |

---

## 14. 将来の拡張性

このモジュラーモノリス設計により、以下の拡張が容易になる:

| 拡張内容 | 実現方法 |
|---------|---------|
| **マイクロサービス化** | モジュール単位で独立サービスに分割（境界が明確） |
| **イベントストア導入** | Spring Application Events → Kafka/RabbitMQに置換 |
| **DB分離** | モジュール単位でDBスキーマ分割（クロスJOIN非依存） |
| **新ドメイン追加** | `modules/<new-module>/` を追加、ArchUnitルール拡張 |

---

## 15. 参考資料

- **アーキテクチャパターン**: [モジュラーモノリス - Martin Fowler](https://martinfowler.com/bliki/MonolithFirst.html)
- **ArchUnit**: [公式ドキュメント](https://www.archunit.org/)
- **Spring Application Events**: [Spring Framework Reference](https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events)
