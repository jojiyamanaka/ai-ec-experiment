# BUG-01: 顧客画面/管理画面のドメイン分離（localhost:5173 / localhost:5174） - 技術設計

## 背景

- 現状は単一フロントエンド（`localhost:5173`）に顧客画面と管理画面が同居している
- 管理画面の導線と認証文脈が URL パス（`/bo`）に依存しているため、ドメイン分離時に不整合が起きる可能性がある
- 最小スコープとして、画面公開面を `5173`（顧客）と `5174`（管理）に分離する

---

## 対応方針（本BUGのスコープ）

### スコープ内

- 顧客画面: `http://localhost:5173`
- 管理画面: `http://localhost:5174`
- フロントエンドの起動系・ルーティング・APIクライアント文脈を分離
- バックエンド CORS を 2 オリジン対応に変更
- Docker Compose の開発導線を 2 フロントエンド構成に変更

### スコープ外

- BFF 導入（CHG-010）
- Core API の非公開化
- 本番ドメイン（`example.com` / `admin.example.com`）運用設計

---

## 影響範囲

- `frontend/`
  - `vite.config.ts`
  - `package.json`
  - `src/App.tsx`
  - `src/lib/api.ts`
  - `src/components/Layout.tsx`
- `backend/`
  - `src/main/resources/application.yml`
  - `src/main/java/com/example/aiec/config/WebConfig.java`
- ルート
  - `docker-compose.yml`
  - `README.md`
  - `docs/test/playwright-runbook.md`（必要に応じて）

---

## 設計原則

- 単一リポジトリ・単一フロントエンド資産を維持しつつ、公開面のみ 2 ドメイン（ポート）に分離する
- 認証文脈は URL パスではなくアプリモード（customer/admin）で判定する
- 既存 API（`/api/**`, `/api/bo/**`, `/api/bo-auth/**`）は原則維持し、移行影響を局所化する
- 将来の BFF 移行（CHG-010）を阻害しない構成にする

---

## 設計詳細

### D-1: フロントエンド起動モードを分離する（customer/admin）

**目的**: 単一ソースのまま 2 つの開発サーバー（5173 / 5174）を起動可能にする。

**設計内容**:

1. `frontend/package.json` に以下の scripts を追加
   - `dev:customer`
   - `dev:admin`
2. `frontend/vite.config.ts` で `mode` に応じて port を切り替える
   - customer: `5173`
   - admin: `5174`
3. 必要に応じて `.env.customer` / `.env.admin` を追加し、`VITE_APP_MODE` を定義

**完了条件**:

- `npm run dev:customer` で `http://localhost:5173` が起動する
- `npm run dev:admin` で `http://localhost:5174` が起動する

---

### D-2: 画面ルーティングをモード別に分離する

**目的**: 顧客画面ビルドから管理画面ルートを除外し、管理画面ビルドから顧客画面ルートを除外する。

**設計内容**:

1. `frontend/src/App.tsx` で `VITE_APP_MODE` を参照し、ルート定義を分岐
2. customer モードでは管理画面ルート（`/bo/*`）を定義しない
3. admin モードでは顧客画面ルートを定義しない（必要最小限: ログイン + 管理画面）
4. customer モードの `Layout` から管理画面リンクを削除する

**完了条件**:

- `http://localhost:5173/bo/item` が表示されない（404/Not Found になる）
- `http://localhost:5174` で管理画面導線のみ利用できる

---

### D-3: APIクライアントの認証文脈を URL 依存からモード依存へ変更する

**目的**: `window.location.pathname.startsWith('/bo')` 依存を廃止し、ドメイン分離後も正しくトークンを送信する。

**設計内容**:

1. `frontend/src/lib/api.ts` の認証ヘッダー付与ロジックを整理
2. `VITE_APP_MODE` を基準に customer/bo の送信トークンを決定
3. 管理機能 API（商品更新、注文管理、在庫管理、会員管理）は bo トークンを必ず使用する
4. 顧客機能 API は authToken を使用する

**完了条件**:

- 管理画面（5174）からの管理 API 呼び出しが 401 にならない
- 顧客画面（5173）から管理 API へ誤って bo トークンが付与されない

---

### D-4: バックエンド CORS を 2 オリジン対応にする

**目的**: `http://localhost:5173` と `http://localhost:5174` の双方から API アクセス可能にする。

**設計内容**:

1. `backend/src/main/resources/application.yml` の `app.cors.allowed-origins` に `http://localhost:5174` を追加
2. `backend/src/main/java/com/example/aiec/config/WebConfig.java` の CORS 設定が上記 2 オリジンを許可することを確認
3. 既存の `/api/bo/**` no-store ヘッダー付与は維持する

**完了条件**:

- 5173/5174 いずれの Origin でも CORS エラーが発生しない

---

### D-5: Docker Compose のフロントエンドサービスを 2 系統化する

**目的**: ローカル開発で顧客画面/管理画面を同時起動できるようにする。

**設計内容**:

1. `docker-compose.yml` の `frontend` サービスを以下へ分割
   - `frontend-customer`（5173）
   - `frontend-admin`（5174）
2. 両サービスで起動コマンドを分ける
   - customer: `npm run dev:customer`
   - admin: `npm run dev:admin`
3. 必要な環境変数（`VITE_APP_MODE` 等）をサービスごとに設定

**完了条件**:

- `docker compose up` 後に 5173/5174 の両方へアクセスできる

---

## 検証コマンド

```bash
# frontend（顧客）
cd frontend
npm run dev:customer

# frontend（管理）
cd frontend
npm run dev:admin

# backend
cd backend
./mvnw spring-boot:run

# CORS確認（Origin 5173）
curl -i http://localhost:8080/api/item \
  -H "Origin: http://localhost:5173"

# CORS確認（Origin 5174）
curl -i http://localhost:8080/api/bo-auth/me \
  -H "Origin: http://localhost:5174"
```

---

## 動作確認と回帰テスト

**目的**: ドメイン分離後に既存機能が壊れていないことを確認する。

**テスト内容**:

1. 顧客画面（5173）
   - 商品一覧、商品詳細、カート、注文作成、注文履歴
2. 管理画面（5174）
   - Boログイン、商品更新、注文管理、在庫管理、会員管理
3. 誤アクセス
   - 5173 側で管理画面 URL を開けないこと
   - 顧客トークンで `/api/bo/**` を叩くと 401/403 になること
4. CORS
   - 5173/5174 の両方で API 通信が成功すること

**完了条件**:

- 上記テストがすべて PASS

---

## リスクと対策

1. 既存 API クライアントが URL パス依存のため、分離直後に 401 が多発する可能性
   - 対策: D-3 を優先して実施し、管理系 API の認証文脈を先に固定する
2. 顧客/管理でルート切り分け漏れが起きる可能性
   - 対策: D-2 でモード別ルート定義を明示的に分岐する
3. 開発環境手順の混乱
   - 対策: README と runbook を同時更新する

---

## 想定工数

- 実装: 1.5 〜 3.0 人日
- 検証: 0.5 〜 1.0 人日
- 合計: 2 〜 4 人日（最小スコープ）
