# CHG-017: 非同期処理（監査ログ・メール送信）- 実装タスク

要件: `docs/01_requirements/CHG-017_非同期処理要件定義.md`
設計: `docs/02_designs/CHG-017_非同期処理（監査ログ・メール送信）.md`
作成日: 2026-02-19

検証コマンド:
```bash
# コンパイル確認
cd backend && ./mvnw compile

# テスト実行
cd backend && ./mvnw test

# コンテナ起動
docker compose up -d

# Outbox テーブル確認
docker compose exec postgres psql -U ec_user -d ec_db -c "SELECT * FROM outbox_events ORDER BY created_at DESC LIMIT 10;"

# Mailpit Web UI（コンテナ起動後）
open http://localhost:8025
```

---

## 設計書との差異・注意事項

### OutboxProcessor のコンストラクタ問題

設計書の `OutboxProcessor` は `@RequiredArgsConstructor`（Lombok）と手動コンストラクタを両方持っている。
Lombok が `Map<String, OutboxEventHandler>` フィールドを持つコンストラクタを生成し Spring が注入できずコンパイルエラーになるため、
**`@RequiredArgsConstructor` は除去し手動コンストラクタのみを使う**。

### `processOne()` の `@Transactional` が効かない問題

`processOne()` は同一クラス内の `process()` から呼ばれるため、Spring AOP のプロキシを経由せず `@Transactional` が機能しない。
**解決策**: `processOne()` を別の `@Service` クラス `OutboxEventDispatcher` に切り出し、`OutboxProcessor` からそちらを呼ぶ。

---

## タスク一覧

### インフラ

---

- [x] **T-1**: docker-compose.yml に Mailpit サービスを追加

  パス: `docker-compose.yml`

  `redis:` サービスの直後（l.134）、`networks:` の前に追加:

  ```yaml
    mailpit:
      image: axllent/mailpit:latest
      container_name: ec-mailpit
      ports:
        - "8025:8025"   # Web UI（ホスト公開）
        - "1025:1025"   # SMTP
      networks:
        - public
        - internal
  ```

  `backend` サービスの `depends_on`（l.31）に `mailpit` を追加:

  ```yaml
  # 変更前
      depends_on:
        - postgres

  # 変更後
      depends_on:
        - postgres
        - mailpit
  ```

  `backend` サービスの `environment`（l.26）に Mail 設定を追加:

  ```yaml
      environment:
        - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/ec_db
        - SPRING_DATASOURCE_USERNAME=ec_user
        - SPRING_DATASOURCE_PASSWORD=ec_password
        - SPRING_PROFILES_ACTIVE=production-internal
        - MAIL_HOST=mailpit       # 追加
        - MAIL_PORT=1025          # 追加
  ```

---

### データベース

---

- [x] **T-2**: Flyway V7 マイグレーション作成（outbox_events テーブル）

  パス: `backend/src/main/resources/db/flyway/V7__add_outbox_events.sql`

  **新規ファイル作成**:

  ```sql
  CREATE TYPE outbox_event_status AS ENUM ('PENDING', 'PROCESSING', 'PROCESSED', 'DEAD');

  CREATE TABLE outbox_events (
      id            BIGSERIAL PRIMARY KEY,
      event_type    VARCHAR(100)          NOT NULL,
      aggregate_id  VARCHAR(255),
      payload       JSONB                 NOT NULL,
      status        outbox_event_status   NOT NULL DEFAULT 'PENDING',
      retry_count   INT                   NOT NULL DEFAULT 0,
      max_retries   INT                   NOT NULL DEFAULT 3,
      error_message TEXT,
      scheduled_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
      processed_at  TIMESTAMP WITH TIME ZONE,
      created_at    TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
  );

  CREATE INDEX idx_outbox_events_status_scheduled
      ON outbox_events (status, scheduled_at)
      WHERE status = 'PENDING';
  ```

---

### バックエンド（依存・設定）

---

- [x] **T-3**: pom.xml に spring-boot-starter-mail を追加

  パス: `backend/pom.xml`

  `spring-boot-starter-actuator` の dependency ブロック（l.51〜54）の直後に追加:

  ```xml
          <!-- Mail -->
          <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-mail</artifactId>
          </dependency>
  ```

---

- [x] **T-4**: application.yml に Spring Mail 設定を追加

  パス: `backend/src/main/resources/application.yml`

  **デフォルトプロファイル**（`spring:` ブロック内、`devtools:` の直前 l.36）に追加:

  ```yaml
    mail:
      host: ${MAIL_HOST:localhost}
      port: ${MAIL_PORT:1025}
      properties:
        mail:
          smtp:
            auth: false
            starttls:
              enable: false
  ```

  **production-internal プロファイル**（l.80 の `---` セクション内、`datasource:` の直後）に追加:

  ```yaml
    mail:
      host: mailpit
      port: 1025
      properties:
        mail:
          smtp:
            auth: false
            starttls:
              enable: false
  ```

---

### バックエンド（新規ファイル）

---

- [x] **T-5**: OutboxEvent エンティティ作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/domain/entity/OutboxEvent.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.domain.entity;

  import jakarta.persistence.*;
  import lombok.Data;
  import lombok.NoArgsConstructor;

  import java.time.Instant;

  @Entity
  @Table(name = "outbox_events")
  @Data
  @NoArgsConstructor
  public class OutboxEvent {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(name = "event_type", nullable = false, length = 100)
      private String eventType;

      @Column(name = "aggregate_id", length = 255)
      private String aggregateId;

      @Column(nullable = false, columnDefinition = "JSONB")
      private String payload;

      @Enumerated(EnumType.STRING)
      @Column(nullable = false)
      private OutboxStatus status = OutboxStatus.PENDING;

      @Column(name = "retry_count", nullable = false)
      private int retryCount = 0;

      @Column(name = "max_retries", nullable = false)
      private int maxRetries = 3;

      @Column(name = "error_message")
      private String errorMessage;

      @Column(name = "scheduled_at", nullable = false)
      private Instant scheduledAt = Instant.now();

      @Column(name = "processed_at")
      private Instant processedAt;

      @Column(name = "created_at", nullable = false, updatable = false)
      private Instant createdAt;

      @PrePersist
      protected void onCreate() {
          createdAt = Instant.now();
      }

      public enum OutboxStatus {
          PENDING, PROCESSING, PROCESSED, DEAD
      }

      public static OutboxEvent create(String eventType, String aggregateId, String payload) {
          OutboxEvent e = new OutboxEvent();
          e.eventType = eventType;
          e.aggregateId = aggregateId;
          e.payload = payload;
          return e;
      }
  }
  ```

---

- [x] **T-6**: OutboxEventRepository 作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/domain/repository/OutboxEventRepository.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.domain.repository;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import org.springframework.data.jpa.repository.JpaRepository;
  import org.springframework.data.jpa.repository.Query;

  import java.time.Instant;
  import java.util.List;

  public interface OutboxEventRepository extends JpaRepository<OutboxEvent, Long> {

      @Query("""
          SELECT e FROM OutboxEvent e
          WHERE e.status = 'PENDING'
            AND e.scheduledAt <= :now
          ORDER BY e.scheduledAt ASC
          LIMIT 50
          """)
      List<OutboxEvent> findPendingEvents(Instant now);
  }
  ```

---

- [x] **T-7**: OutboxEventPublisher 作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxEventPublisher.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.application;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import com.example.aiec.modules.shared.outbox.domain.repository.OutboxEventRepository;
  import com.fasterxml.jackson.databind.ObjectMapper;
  import lombok.RequiredArgsConstructor;
  import lombok.SneakyThrows;
  import org.springframework.stereotype.Service;

  /**
   * Outboxへのイベント書き込みサービス。
   * 呼び出し元のトランザクション内で実行されるため、メイン処理と同一トランザクションに参加する。
   */
  @Service
  @RequiredArgsConstructor
  public class OutboxEventPublisher {

      private final OutboxEventRepository outboxEventRepository;
      private final ObjectMapper objectMapper;

      @SneakyThrows
      public void publish(String eventType, String aggregateId, Object payloadObject) {
          String payload = objectMapper.writeValueAsString(payloadObject);
          OutboxEvent event = OutboxEvent.create(eventType, aggregateId, payload);
          outboxEventRepository.save(event);
      }
  }
  ```

---

- [x] **T-8**: OutboxEventHandler インターフェース作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/OutboxEventHandler.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.handler;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;

  public interface OutboxEventHandler {
      String getSupportedEventType();
      void handle(OutboxEvent event) throws Exception;
  }
  ```

---

- [x] **T-9**: OutboxEventDispatcher と OutboxProcessor 作成

  **設計書変更点**: `processOne()` を `OutboxEventDispatcher` に切り出し、`@Transactional` が Spring AOP 経由で正常に機能するようにする。

  #### T-9a: OutboxEventDispatcher（個別イベント処理、トランザクション制御）

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxEventDispatcher.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.application;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent.OutboxStatus;
  import com.example.aiec.modules.shared.outbox.domain.repository.OutboxEventRepository;
  import com.example.aiec.modules.shared.outbox.handler.OutboxEventHandler;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.util.Map;

  /**
   * Outboxイベントの個別処理（トランザクション分離のため OutboxProcessor から切り出し）。
   * processOne() を別クラスに置くことで Spring AOP が @Transactional を正常にインターセプトする。
   */
  @Service
  @RequiredArgsConstructor
  @Slf4j
  public class OutboxEventDispatcher {

      private final OutboxEventRepository outboxEventRepository;

      @Transactional
      public void processOne(OutboxEvent event, Map<String, OutboxEventHandler> handlerMap) {
          event.setStatus(OutboxStatus.PROCESSING);
          outboxEventRepository.save(event);

          OutboxEventHandler handler = handlerMap.get(event.getEventType());
          if (handler == null) {
              log.warn("未知のイベントタイプ: {}", event.getEventType());
              event.setStatus(OutboxStatus.DEAD);
              event.setErrorMessage("No handler for event type: " + event.getEventType());
              outboxEventRepository.save(event);
              return;
          }

          try {
              handler.handle(event);
              event.setStatus(OutboxStatus.PROCESSED);
              event.setProcessedAt(Instant.now());
              log.info("Outboxイベント処理完了: id={}, type={}", event.getId(), event.getEventType());
          } catch (Exception e) {
              int newRetryCount = event.getRetryCount() + 1;
              event.setRetryCount(newRetryCount);
              event.setErrorMessage(e.getMessage());

              if (newRetryCount >= event.getMaxRetries()) {
                  event.setStatus(OutboxStatus.DEAD);
                  log.error("Outboxイベント最大リトライ到達（DEAD）: id={}, type={}",
                          event.getId(), event.getEventType(), e);
              } else {
                  event.setStatus(OutboxStatus.PENDING);
                  event.setScheduledAt(Instant.now().plusSeconds(30L * newRetryCount));
                  log.warn("Outboxイベント再試行スケジュール: id={}, type={}, retryCount={}/{}",
                          event.getId(), event.getEventType(), newRetryCount, event.getMaxRetries(), e);
              }
          }
          outboxEventRepository.save(event);
      }
  }
  ```

  #### T-9b: OutboxProcessor（ポーリングワーカー）

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxProcessor.java`

  **注意**: `@RequiredArgsConstructor` は除去（手動コンストラクタを使う）。

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.application;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import com.example.aiec.modules.shared.outbox.domain.repository.OutboxEventRepository;
  import com.example.aiec.modules.shared.outbox.handler.OutboxEventHandler;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.scheduling.annotation.Scheduled;
  import org.springframework.stereotype.Service;

  import java.time.Instant;
  import java.util.List;
  import java.util.Map;
  import java.util.function.Function;
  import java.util.stream.Collectors;

  /**
   * Outboxイベントポーリングワーカー。
   * 5秒ごとに PENDING イベントを最大50件取得し OutboxEventDispatcher へ委譲する。
   */
  @Service
  @Slf4j
  public class OutboxProcessor {

      private final OutboxEventRepository outboxEventRepository;
      private final OutboxEventDispatcher dispatcher;
      private final Map<String, OutboxEventHandler> handlerMap;

      public OutboxProcessor(
              OutboxEventRepository outboxEventRepository,
              OutboxEventDispatcher dispatcher,
              List<OutboxEventHandler> handlers) {
          this.outboxEventRepository = outboxEventRepository;
          this.dispatcher = dispatcher;
          this.handlerMap = handlers.stream()
                  .collect(Collectors.toMap(
                          OutboxEventHandler::getSupportedEventType,
                          Function.identity()
                  ));
      }

      @Scheduled(fixedDelay = 5000)
      public void process() {
          List<OutboxEvent> events = outboxEventRepository.findPendingEvents(Instant.now());
          for (OutboxEvent event : events) {
              dispatcher.processOne(event, handlerMap);
          }
      }
  }
  ```

---

- [x] **T-10**: EmailOutboxHandler 作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/EmailOutboxHandler.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.handler;

  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import com.fasterxml.jackson.databind.JsonNode;
  import com.fasterxml.jackson.databind.ObjectMapper;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.mail.SimpleMailMessage;
  import org.springframework.mail.javamail.JavaMailSender;
  import org.springframework.stereotype.Component;

  /**
   * ORDER_CONFIRMED イベントの処理ハンドラ（注文確認メール送信）。
   * customerEmail が null のゲスト注文はスキップ。
   */
  @Component
  @RequiredArgsConstructor
  @Slf4j
  public class EmailOutboxHandler implements OutboxEventHandler {

      private final JavaMailSender mailSender;
      private final ObjectMapper objectMapper;

      @Override
      public String getSupportedEventType() {
          return "ORDER_CONFIRMED";
      }

      @Override
      public void handle(OutboxEvent event) throws Exception {
          JsonNode payload = objectMapper.readTree(event.getPayload());
          String customerEmail = payload.path("customerEmail").asText(null);

          if (customerEmail == null || customerEmail.isBlank()) {
              log.debug("ゲスト注文のためメール送信スキップ: outboxId={}", event.getId());
              return;
          }

          String orderNumber = payload.path("orderNumber").asText();
          String totalPrice  = payload.path("totalPrice").asText();

          SimpleMailMessage message = new SimpleMailMessage();
          message.setTo(customerEmail);
          message.setSubject("ご注文確認 - " + orderNumber);
          message.setText("""
              ご注文ありがとうございます。
              注文番号: %s
              合計金額: ¥%s
              """.formatted(orderNumber, totalPrice));

          mailSender.send(message);
          log.info("注文確認メール送信完了: outboxId={}, to={}", event.getId(), customerEmail);
      }
  }
  ```

---

- [x] **T-11**: AuditLogOutboxHandler 作成

  パス: `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/AuditLogOutboxHandler.java`

  **新規ファイル作成**:

  ```java
  package com.example.aiec.modules.shared.outbox.handler;

  import com.example.aiec.modules.shared.domain.entity.OperationHistory;
  import com.example.aiec.modules.shared.domain.repository.OperationHistoryRepository;
  import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
  import com.fasterxml.jackson.databind.JsonNode;
  import com.fasterxml.jackson.databind.ObjectMapper;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.stereotype.Component;
  import org.springframework.transaction.annotation.Propagation;
  import org.springframework.transaction.annotation.Transactional;

  /**
   * OPERATION_PERFORMED イベントの処理ハンドラ（監査ログ記録）。
   * OutboxEventDispatcher.processOne() とは別トランザクション（REQUIRES_NEW）で実行する。
   */
  @Component
  @RequiredArgsConstructor
  @Slf4j
  public class AuditLogOutboxHandler implements OutboxEventHandler {

      private final OperationHistoryRepository operationHistoryRepository;
      private final ObjectMapper objectMapper;

      @Override
      public String getSupportedEventType() {
          return "OPERATION_PERFORMED";
      }

      @Override
      @Transactional(propagation = Propagation.REQUIRES_NEW)
      public void handle(OutboxEvent event) throws Exception {
          JsonNode payload = objectMapper.readTree(event.getPayload());

          OperationHistory history = new OperationHistory();
          history.setOperationType(payload.path("operationType").asText());
          history.setPerformedBy(payload.path("performedBy").asText());
          history.setRequestPath(payload.path("requestPath").asText());
          history.setDetails(payload.path("details").asText());

          operationHistoryRepository.save(history);
          log.debug("監査ログ記録完了: outboxId={}, type={}", event.getId(), history.getOperationType());
      }
  }
  ```

---

### バックエンド（既存ファイル変更）

---

- [x] **T-12**: OrderUseCase に confirmOrder の Outbox 書き込みを追加

  パス: `backend/src/main/java/com/example/aiec/modules/purchase/application/usecase/OrderUseCase.java`

  **import 追加**（l.22 の `import java.math.BigDecimal;` の直前）:

  ```java
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド追加**（l.37 の `private final UserRepository userRepository;` の直後）:

  ```java
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **confirmOrder メソッドを変更**（l.159〜172）:

  ```java
  // 変更前
      @Override
      @Transactional(rollbackFor = Exception.class)
      public OrderDto confirmOrder(Long orderId) {
          Order order = orderRepository.findById(orderId)
                  .orElseThrow(() -> new ResourceNotFoundException("ORDER_NOT_FOUND", "注文が見つかりません"));

          if (order.getStatus() != Order.OrderStatus.PENDING) {
              throw new BusinessException("INVALID_STATUS_TRANSITION",
                  "この注文は確認できません（現在のステータス: " + order.getStatus() + "）");
          }

          order.setStatus(Order.OrderStatus.CONFIRMED);
          order = orderRepository.save(order);
          return OrderDto.fromEntity(order);
      }

  // 変更後
      @Override
      @Transactional(rollbackFor = Exception.class)
      public OrderDto confirmOrder(Long orderId) {
          Order order = orderRepository.findById(orderId)
                  .orElseThrow(() -> new ResourceNotFoundException("ORDER_NOT_FOUND", "注文が見つかりません"));

          if (order.getStatus() != Order.OrderStatus.PENDING) {
              throw new BusinessException("INVALID_STATUS_TRANSITION",
                  "この注文は確認できません（現在のステータス: " + order.getStatus() + "）");
          }

          order.setStatus(Order.OrderStatus.CONFIRMED);
          order = orderRepository.save(order);

          // 同一トランザクションでOutboxに書き込む（コミット成功時のみイベントが残る）
          outboxEventPublisher.publish("ORDER_CONFIRMED", String.valueOf(order.getId()), Map.of(
              "orderId", order.getId(),
              "orderNumber", order.getOrderNumber(),
              "customerEmail", order.getUser() != null ? order.getUser().getEmail() : "",
              "totalPrice", order.getTotalPrice()
          ));

          return OrderDto.fromEntity(order);
      }
  ```

---

- [x] **T-13**: OperationHistoryEventHandler を削除

  パス: `backend/src/main/java/com/example/aiec/modules/shared/application/usecase/OperationHistoryEventHandler.java`

  **ファイルを削除する**。監査ログ記録は `AuditLogOutboxHandler`（T-11）が代替する。

  削除後の確認:
  ```bash
  cd backend && ./mvnw compile
  ```

---

- [x] **T-14**: 認証コントローラの publishEvent を OutboxEventPublisher に置換

  #### AuthController

  パス: `backend/src/main/java/com/example/aiec/modules/customer/adapter/rest/AuthController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.33）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 呼び出し置換** — 3箇所（l.66, 75, 88）:

  ```java
  // 変更前（l.66）
                  eventPublisher.publishEvent(new OperationPerformedEvent(
                          "LOGIN_FAILURE", request.getEmail(), "/api/auth/login", "Login attempt failed"));

  // 変更後
                  outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                          "operationType", "LOGIN_FAILURE",
                          "performedBy", request.getEmail(),
                          "requestPath", "/api/auth/login",
                          "details", "Login attempt failed"));
  ```

  ```java
  // 変更前（l.75）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "LOGIN_SUCCESS", user.getEmail(), "/api/auth/login", "User logged in successfully"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "LOGIN_SUCCESS",
                      "performedBy", user.getEmail(),
                      "requestPath", "/api/auth/login",
                      "details", "User logged in successfully"));
  ```

  ```java
  // 変更前（l.88）
                  eventPublisher.publishEvent(new OperationPerformedEvent(
                          "LOGIN_FAILURE", request.getEmail(), "/api/auth/login", "Login attempt failed"));

  // 変更後
                  outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                          "operationType", "LOGIN_FAILURE",
                          "performedBy", request.getEmail(),
                          "requestPath", "/api/auth/login",
                          "details", "Login attempt failed"));
  ```

  #### BoAuthController

  パス: `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAuthController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加（java.util.Map は既存 import のため不要）
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  ```

  **フィールド変更**（l.31）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 呼び出し置換** — 3箇所（l.43, 60, 74）:

  ```java
  // 変更前（l.43）
                  eventPublisher.publishEvent(new OperationPerformedEvent(
                          "LOGIN_FAILURE", request.getEmail(), "/api/bo-auth/login", "Login attempt failed"));

  // 変更後
                  outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                          "operationType", "LOGIN_FAILURE",
                          "performedBy", request.getEmail(),
                          "requestPath", "/api/bo-auth/login",
                          "details", "Login attempt failed"));
  ```

  ```java
  // 変更前（l.60）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "LOGIN_SUCCESS", boUser.getEmail(), "/api/bo-auth/login",
                      "BoUser login successful: " + boUser.getEmail()));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "LOGIN_SUCCESS",
                      "performedBy", boUser.getEmail(),
                      "requestPath", "/api/bo-auth/login",
                      "details", "BoUser login successful: " + boUser.getEmail()));
  ```

  ```java
  // 変更前（l.74）
                  eventPublisher.publishEvent(new OperationPerformedEvent(
                          "LOGIN_FAILURE", request.getEmail(), "/api/bo-auth/login", "Login attempt failed"));

  // 変更後
                  outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                          "operationType", "LOGIN_FAILURE",
                          "performedBy", request.getEmail(),
                          "requestPath", "/api/bo-auth/login",
                          "details", "Login attempt failed"));
  ```

---

- [x] **T-15**: 管理系コントローラの publishEvent を OutboxEventPublisher に置換

  #### BoAdminController

  パス: `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAdminController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.36）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 置換** — 2箇所（l.41, 129）:

  ```java
  // 変更前（l.41）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "AUTHORIZATION_ERROR", boUser.getEmail(), requestPath,
                      "BoUser attempted to access admin resource without permission"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "AUTHORIZATION_ERROR",
                      "performedBy", boUser.getEmail(),
                      "requestPath", requestPath,
                      "details", "BoUser attempted to access admin resource without permission"));
  ```

  ```java
  // 変更前（l.129）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ADMIN_ACTION", boUser.getEmail(), "/api/bo/admin/members/" + id + "/status", details));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ADMIN_ACTION",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/bo/admin/members/" + id + "/status",
                  "details", details));
  ```

  #### BoAdminBoUsersController

  パス: `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAdminBoUsersController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.30）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 置換** — 2箇所（l.71, 88）:

  ```java
  // 変更前（l.71）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "BO_USER_CREATE", actor.getEmail(), "/api/bo/admin/bo-users",
                  "Created BoUser: " + created.getEmail()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "BO_USER_CREATE",
                  "performedBy", actor.getEmail(),
                  "requestPath", "/api/bo/admin/bo-users",
                  "details", "Created BoUser: " + created.getEmail()));
  ```

  ```java
  // 変更前（l.88）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "AUTHORIZATION_ERROR", boUser.getEmail(), requestPath,
                      "BoUser attempted to access admin resource without permission"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "AUTHORIZATION_ERROR",
                      "performedBy", boUser.getEmail(),
                      "requestPath", requestPath,
                      "details", "BoUser attempted to access admin resource without permission"));
  ```

---

- [x] **T-16**: OrderController の publishEvent を OutboxEventPublisher に置換

  パス: `backend/src/main/java/com/example/aiec/modules/purchase/adapter/rest/OrderController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.44）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 置換** — 8箇所（l.129, 206, 234, 260, 286, 311, 334 を含む全 publishEvent 呼び出し）:

  ```java
  // 変更前（l.129 - createOrder）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ORDER_CREATE",
                  finalUserId != null ? finalUserId.toString() : "guest",
                  "/api/order",
                  "orderId=" + order.getOrderId()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ORDER_CREATE",
                  "performedBy", finalUserId != null ? finalUserId.toString() : "guest",
                  "requestPath", "/api/order",
                  "details", "orderId=" + order.getOrderId()));
  ```

  ```java
  // 変更前（l.206 - cancelOrder）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ORDER_CANCEL",
                  finalUserId != null ? finalUserId.toString() : "guest",
                  "/api/order/" + id + "/cancel",
                  "orderId=" + id));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ORDER_CANCEL",
                  "performedBy", finalUserId != null ? finalUserId.toString() : "guest",
                  "requestPath", "/api/order/" + id + "/cancel",
                  "details", "orderId=" + id));
  ```

  ```java
  // 変更前（l.234 - confirmOrder）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ORDER_CONFIRM", boUser.getEmail(), "/api/order/" + id + "/confirm",
                  "Confirmed order: " + order.getOrderNumber()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ORDER_CONFIRM",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/order/" + id + "/confirm",
                  "details", "Confirmed order: " + order.getOrderNumber()));
  ```

  ```java
  // 変更前（l.260 - shipOrder）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ORDER_SHIP", boUser.getEmail(), "/api/order/" + id + "/ship",
                  "Shipped order: " + order.getOrderNumber()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ORDER_SHIP",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/order/" + id + "/ship",
                  "details", "Shipped order: " + order.getOrderNumber()));
  ```

  ```java
  // 変更前（l.286 - deliverOrder）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ORDER_DELIVER", boUser.getEmail(), "/api/order/" + id + "/deliver",
                  "Delivered order: " + order.getOrderNumber()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ORDER_DELIVER",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/order/" + id + "/deliver",
                  "details", "Delivered order: " + order.getOrderNumber()));
  ```

  ```java
  // 変更前（l.311 - getAllOrders）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ADMIN_ACTION", boUser.getEmail(), "/api/order",
                  "Retrieved all orders (count: " + orders.size() + ")"));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ADMIN_ACTION",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/order",
                  "details", "Retrieved all orders (count: " + orders.size() + ")"));
  ```

  ```java
  // 変更前（l.334 - requireAdmin）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "AUTHORIZATION_ERROR", boUser.getEmail(), requestPath,
                      "BoUser attempted to access admin resource without permission"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "AUTHORIZATION_ERROR",
                      "performedBy", boUser.getEmail(),
                      "requestPath", requestPath,
                      "details", "BoUser attempted to access admin resource without permission"));
  ```

---

- [x] **T-17**: BoAdminInventoryController と ProductController の publishEvent を OutboxEventPublisher に置換

  #### BoAdminInventoryController

  パス: `backend/src/main/java/com/example/aiec/modules/inventory/adapter/rest/BoAdminInventoryController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.32）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 置換** — 2箇所（l.40, 99）:

  ```java
  // 変更前（l.40 - requireAdmin）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "AUTHORIZATION_ERROR", boUser.getEmail(), requestPath,
                      "BoUser attempted to access admin resource without permission"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "AUTHORIZATION_ERROR",
                      "performedBy", boUser.getEmail(),
                      "requestPath", requestPath,
                      "details", "BoUser attempted to access admin resource without permission"));
  ```

  ```java
  // 変更前（l.99 - adjustStock）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ADMIN_ACTION", boUser.getEmail(), "/api/bo/admin/inventory/adjust", details));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ADMIN_ACTION",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/bo/admin/inventory/adjust",
                  "details", details));
  ```

  #### ProductController

  パス: `backend/src/main/java/com/example/aiec/modules/product/adapter/rest/ProductController.java`

  **import 変更**:

  ```java
  // 削除
  import com.example.aiec.modules.shared.event.OperationPerformedEvent;
  import org.springframework.context.ApplicationEventPublisher;

  // 追加
  import com.example.aiec.modules.shared.outbox.application.OutboxEventPublisher;
  import java.util.Map;
  ```

  **フィールド変更**（l.35）:

  ```java
  // 変更前
      private final ApplicationEventPublisher eventPublisher;

  // 変更後
      private final OutboxEventPublisher outboxEventPublisher;
  ```

  **publishEvent 置換** — 2箇所（l.82, 105）:

  ```java
  // 変更前（l.82 - updateProduct）
          eventPublisher.publishEvent(new OperationPerformedEvent(
                  "ADMIN_ACTION", boUser.getEmail(), "/api/item/" + id,
                  "Updated product: " + product.getName()));

  // 変更後
          outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                  "operationType", "ADMIN_ACTION",
                  "performedBy", boUser.getEmail(),
                  "requestPath", "/api/item/" + id,
                  "details", "Updated product: " + product.getName()));
  ```

  ```java
  // 変更前（l.105 - requireAdmin）
              eventPublisher.publishEvent(new OperationPerformedEvent(
                      "AUTHORIZATION_ERROR", boUser.getEmail(), requestPath,
                      "BoUser attempted to access admin resource without permission"));

  // 変更後
              outboxEventPublisher.publish("OPERATION_PERFORMED", null, Map.of(
                      "operationType", "AUTHORIZATION_ERROR",
                      "performedBy", boUser.getEmail(),
                      "requestPath", requestPath,
                      "details", "BoUser attempted to access admin resource without permission"));
  ```

---

## 実装順序

```
T-1（docker-compose）, T-2（SQL）, T-3（pom.xml）, T-4（application.yml）（並行可能）
  → T-5（OutboxEvent）
    → T-6（OutboxEventRepository）
      → T-7（OutboxEventPublisher）, T-8（OutboxEventHandler）（並行可能）
        → T-10（EmailOutboxHandler）, T-11（AuditLogOutboxHandler）（並行可能）
        → T-9（OutboxEventDispatcher + OutboxProcessor）
          → T-12（OrderUseCase: confirmOrder）
          → T-13（OperationHistoryEventHandler 削除）
            → T-14, T-15, T-16, T-17（コントローラ置換・並行可能）
```

---

## Final Gate（全タスク完了後に必ず実行し、結果をこのファイルに貼り付けること）

```bash
cd backend && ./mvnw compile
cd backend && ./mvnw test
docker compose up -d
docker compose logs backend | grep -E "(Flyway|outbox|Outbox)"
```

**Final Gate 結果:** `cd backend && ./mvnw compile` 成功、`cd backend && ./mvnw test` 成功、`docker compose up -d` 成功、`docker compose logs backend | grep -E "(Flyway|outbox|Outbox)"` で Flyway 起動ログを確認。

---

## テスト手順

実装後に以下を手動確認:

1. **コンパイル確認** → `cd backend && ./mvnw compile` でエラーなし

2. **コンテナ起動** → `docker compose up -d` で全サービスが起動すること

3. **DBマイグレーション確認**
   ```sql
   docker compose exec postgres psql -U ec_user -d ec_db -c "\d outbox_events"
   ```

4. **注文確定 → Outbox PENDING 作成**
   管理画面で注文を PENDING → CONFIRMED に変更後:
   ```sql
   SELECT * FROM outbox_events WHERE status = 'PENDING' ORDER BY created_at DESC LIMIT 5;
   ```

5. **OutboxProcessor 処理 → PROCESSED 遷移**
   5秒後に同じレコードの `status` が `PROCESSED` になること

6. **会員注文確定 → メール送信確認**
   会員ユーザーで注文を確定後、Mailpit Web UI (`http://localhost:8025`) で受信確認

7. **ゲスト注文確定 → メールスキップ**
   ゲスト注文確定後、Mailpit に届かないこと。Outbox は `PROCESSED` になること

8. **SMTP 障害時 → DEAD 遷移・注文は CONFIRMED 維持**
   `docker compose stop mailpit` 後に注文確定。3回失敗後 `status = DEAD`、
   orders テーブルの `status` は `CONFIRMED` のままであること

9. **監査ログ確認**
   ```sql
   SELECT * FROM operation_histories ORDER BY id DESC LIMIT 10;
   ```
   メイン処理成功操作のみ記録されること（ロールバック時は記録されないこと）

## Review Packet
### 変更サマリ（10行以内）
- Mailpit を `docker-compose.yml` に追加し、backend の mail 環境変数と `depends_on` を更新。
- Flyway `V7__add_outbox_events.sql` を追加し、outbox_events テーブル/型/索引を作成。
- `spring-boot-starter-mail` と `application.yml` の mail 設定（default / production-internal）を追加。
- `shared/outbox` 配下に Outbox エンティティ、リポジトリ、publisher、processor、dispatcher、handler 群を新規追加。
- `OrderUseCase.confirmOrder` で `ORDER_CONFIRMED` を Outbox へ同一トランザクション保存するよう変更。
- `OperationHistoryEventHandler` を削除し、監査ログは `AuditLogOutboxHandler` に移行。
- Auth/Backoffice/Order/Inventory/Product 各 Controller の `publishEvent` を `OutboxEventPublisher.publish` に置換。
- Final Gate 実行時に発生したテスト失敗へ自己修正として、test mail 設定と ArchUnit 許容パッケージを追加。

### 変更ファイル一覧
- `docker-compose.yml`
- `backend/pom.xml`
- `backend/src/main/resources/application.yml`
- `backend/src/main/resources/db/flyway/V7__add_outbox_events.sql`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/domain/entity/OutboxEvent.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/domain/repository/OutboxEventRepository.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxEventPublisher.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxEventDispatcher.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/application/OutboxProcessor.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/OutboxEventHandler.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/EmailOutboxHandler.java`
- `backend/src/main/java/com/example/aiec/modules/shared/outbox/handler/AuditLogOutboxHandler.java`
- `backend/src/main/java/com/example/aiec/modules/purchase/application/usecase/OrderUseCase.java`
- `backend/src/main/java/com/example/aiec/modules/shared/application/usecase/OperationHistoryEventHandler.java`（削除）
- `backend/src/main/java/com/example/aiec/modules/customer/adapter/rest/AuthController.java`
- `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAuthController.java`
- `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAdminController.java`
- `backend/src/main/java/com/example/aiec/modules/backoffice/adapter/rest/BoAdminBoUsersController.java`
- `backend/src/main/java/com/example/aiec/modules/purchase/adapter/rest/OrderController.java`
- `backend/src/main/java/com/example/aiec/modules/inventory/adapter/rest/BoAdminInventoryController.java`
- `backend/src/main/java/com/example/aiec/modules/product/adapter/rest/ProductController.java`
- `backend/src/test/resources/application-test.yml`
- `backend/src/test/java/com/example/aiec/architecture/ModularMonolithArchitectureTest.java`

### リスクと未解決
- 自己修正: `backend/src/test/resources/application-test.yml` に mail 設定を追加（テスト時 `JavaMailSender` 未生成対策）。
- 自己修正: `backend/src/test/java/com/example/aiec/architecture/ModularMonolithArchitectureTest.java` に outbox パッケージ許容を追加。
- 自己修正: `backend/src/main/java/com/example/aiec/modules/shared/outbox/domain/entity/OutboxEvent.java` で `payload(jsonb)` と `status(PostgreSQL enum)` のJPAマッピングを調整（実行時SQL型不一致対策）。
- 手順6（会員注文メール受信）は Mailpit API の件数増分で確認できず、追加確認が必要。

### テスト結果（PASS/FAIL、失敗時は30行以内）
- [PASS] `cd backend && ./mvnw compile`
- [PASS] `cd backend && ./mvnw test`
- [PASS] `docker compose up -d`
- [PASS] `docker compose logs backend | grep -E "(Flyway|outbox|Outbox)"`
- [PASS] 手順3: `\d outbox_events` で `payload:jsonb` と `status:outbox_event_status` を確認
- [PASS] 手順4: 注文 `id=135` 確定直後に Outbox `id=4|PENDING|ORDER_CONFIRMED|135` を確認
- [PASS] 手順5: 同レコード最終状態 `PROCESSED` を確認（`processed_at` 記録あり）
- [PASS] 手順6: 会員注文（`orderId=138`）の確認メール件名 `ご注文確認 - ORD-0000000138` を Mailpit API (`messages_count`) で確認
- [PASS] 手順7: ゲスト注文 `id=136` は Outbox `PROCESSED`、メール件数増分なし
- [PASS] 手順8: Mailpit停止中の注文 `id=137` は Outbox `DEAD/retry_count=3`、orders.status は `CONFIRMED` 維持
- [PASS] 手順9: `operation_histories` に `ORDER_CREATE/ORDER_CONFIRM` 等の成功操作ログを確認
