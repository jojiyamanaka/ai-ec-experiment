# CHG-009: SQLite から PostgreSQL への移行

## 背景・課題

### 現状の問題点

現在のシステムは SQLite を利用しており、以下の課題があります：

1. **同時書き込み性能の制約**
   - SQLite は書き込み競合時にデータベース全体ロックが発生しやすい
   - 注文作成・在庫更新・管理画面操作が重なると待ち時間が増える

2. **運用・保守の拡張性不足**
   - 本番運用を想定したバックアップ、レプリケーション、監視機能が限定的
   - 将来的なスケールアウト（複数アプリインスタンス）に不向き

3. **DB 方言差異による将来コスト**
   - SQLite 固有の挙動に依存した実装は、将来の DB 変更時に修正範囲が拡大する
   - 早期に標準的な RDBMS に移行し、開発・運用の安定性を高める必要がある

### なぜ必要か

- **可用性向上**: 本番運用に適したバックアップ・復旧・監視体制を整える
- **性能向上**: 同時アクセス時の書き込み競合を緩和する
- **拡張性確保**: 中長期の機能追加・運用拡大に耐える基盤にする
- **保守性向上**: 標準的な SQL / トランザクション機能を前提とした設計に寄せる

---

## ビジネス要件

### 1. データベース基盤の移行

#### 1.1 移行先
- データベースは PostgreSQL（例: 16 系）を採用する
- 開発・検証・本番で同一系統の DB エンジンを利用する

#### 1.2 接続設定
- DB 接続は環境変数で切り替え可能にする（URL / ユーザー / パスワード）
- ローカル開発は Docker Compose で PostgreSQL を起動できるようにする

#### 1.3 既存機能の継続
- 既存の API 契約（リクエスト/レスポンス形式）は維持する
- 既存の顧客機能・管理機能は移行後も同等の挙動を維持する

### 2. スキーマとデータの移行

#### 2.1 スキーマ移行
- SQLite の現行テーブル構造を PostgreSQL に移植する
- 主キー、外部キー、UNIQUE、NOT NULL、インデックス定義を移行する

#### 2.2 データ移行
- 既存データ（ユーザー、商品、在庫、カート、注文、認証トークン、操作履歴）を欠損なく移行する
- 移行後のデータ件数・整合性が移行前と一致することを検証する

#### 2.3 型と制約の正規化
- 日時型、真偽値、文字列長、数値型を PostgreSQL で適切な型に統一する
- 将来のデータ不整合を防ぐため、必要な制約（CHECK 等）を明確化する

### 3. アプリケーション実装の移行

#### 3.1 バックエンド設定変更
- SQLite JDBC / Dialect 依存を PostgreSQL 向け設定に置き換える
- JPA/Hibernate 設定を PostgreSQL 向けに調整する

#### 3.2 トランザクション・排他制御の見直し
- SQLite 前提の排他制御方針を見直し、PostgreSQL の行ロック・分離レベルに合わせる
- 在庫引当・注文確定など整合性が重要な処理は競合時の挙動を明文化する

#### 3.3 開発・運用手順の更新
- 開発環境の起動手順、初期データ投入、バックアップ/リストア手順を更新する
- 既存ドキュメント（技術仕様、テスト手順）を PostgreSQL 前提に更新する

### 4. 移行方式

#### 4.1 初回移行
- SQLite から PostgreSQL への一括移行手順を定義する
- 移行スクリプトは再現性のある手順として残す

#### 4.2 ロールバック
- 本番移行時に問題が発生した場合のロールバック手順を定義する
- ロールバック判断基準（エラー率、性能劣化、データ不整合）を事前に定義する

---

## 受け入れ条件

### 必須要件

1. **PostgreSQL での起動**
   - [ ] バックエンドが PostgreSQL 接続で正常起動すること
   - [ ] 起動時に SQL エラーやスキーマ不整合が発生しないこと

2. **機能互換性**
   - [ ] 顧客向け主要機能（商品閲覧、カート、注文）が移行前と同等に動作すること
   - [ ] 管理機能（商品管理、注文管理、在庫管理、会員管理）が移行前と同等に動作すること

3. **データ移行の完全性**
   - [ ] 主要テーブルの件数が移行前後で一致すること
   - [ ] 参照整合性（外部キー）が保たれていること
   - [ ] 移行後に業務上重要なデータ欠損がないこと

4. **性能・安定性**
   - [ ] 同時注文など競合が発生するシナリオで致命的なエラーが発生しないこと
   - [ ] 移行前と比較して著しい性能劣化がないこと

5. **運用性**
   - [ ] バックアップおよびリストア手順が実施可能であること
   - [ ] 障害時のロールバック手順が検証済みであること

### テスト項目

1. **移行リハーサル**
   - [ ] SQLite ダンプ取得 → PostgreSQL 取り込みを検証環境で実施すること
   - [ ] リハーサル後の件数照合、代表データ照合を実施すること

2. **回帰テスト**
   - [ ] 既存 API の主要シナリオ（正常系/異常系）を実施し、挙動差分がないことを確認すること
   - [ ] フロントエンドの主要画面フローで回帰がないことを確認すること

3. **競合テスト**
   - [ ] 同一商品に対する同時注文で在庫整合性が維持されること
   - [ ] 管理画面での在庫更新と注文処理が同時実行されても整合性が保たれること

4. **運用テスト**
   - [ ] バックアップ取得とリストアを実施し、復旧後に主要機能が動作すること
   - [ ] ロールバック手順を検証環境で 1 回以上実施すること

### 任意要件（将来対応）

- [ ] マイグレーション管理ツール（Flyway / Liquibase）を導入し、スキーマ変更を履歴管理する
- [ ] 読み取り負荷分散（Read Replica）を見据えた接続設計を追加する
- [ ] PostgreSQL の監視項目（スロークエリ、接続数、ロック待ち）をダッシュボード化する

---

## 影響範囲

### データベース
- SQLite ファイル運用（`ec.db`）から PostgreSQL インスタンス運用へ変更
- テーブル定義、インデックス、制約の PostgreSQL 最適化
- データ移行スクリプトおよび移行検証手順の追加

### バックエンド
- JDBC ドライバ、Dialect、Datasource 設定の変更
- 排他制御方針（在庫・注文系トランザクション）の見直し
- DB 初期化・テストデータ投入処理の更新

### フロントエンド
- 基本的に API 契約を維持するため、機能変更は不要
- ただし回帰確認（API 応答時間、エラー表示）は必須

### インフラ・運用
- `docker-compose.yml` の DB サービス追加・更新
- 環境変数管理（接続情報、認証情報）とシークレット管理の整備
- バックアップ、監視、障害対応 Runbook の更新

### ドキュメント
- 技術仕様書（`docs/SPEC.md`）の DB 記載更新
- DB 関連仕様（在庫・注文・ギャップ分析）の前提更新
- テスト手順書の DB セットアップ手順更新

---

## 非機能要件

### 可用性
- 定期バックアップとリストア手順を確立し、復旧目標時間を定義する

### 性能
- 主要 API の応答時間が現行運用を下回らないこと
- 同時アクセス時でも業務継続可能なスループットを維持すること

### セキュリティ
- DB 接続情報を環境変数・シークレット管理で保護すること
- DB 権限は最小権限の原則で付与すること

### 保守性
- スキーマ変更手順を標準化し、変更履歴を追跡可能にすること
- 開発者がローカルで再現可能な DB 起動・初期化手順を提供すること

---

## 備考

### 段階的な移行戦略

#### Phase 1: 移行準備
1. PostgreSQL の開発環境整備
2. スキーマ定義の移植
3. データ移行手順の作成

#### Phase 2: 検証
1. 移行リハーサル
2. 回帰テスト / 競合テスト
3. 性能測定

#### Phase 3: 本番移行
1. メンテナンス時間帯での本番データ移行
2. 移行後検証（件数、主要 API、業務シナリオ）
3. 問題発生時のロールバック判断と実施

### 注意事項

- 本要件は「SQLite から PostgreSQL への移行」を対象とし、業務機能の追加は対象外とする
- API 契約変更が必要な場合は別 CHG として扱う
- 移行作業前に必ずバックアップを取得する
