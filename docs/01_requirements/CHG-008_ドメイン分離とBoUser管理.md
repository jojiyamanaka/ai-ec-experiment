# CHG-008: ドメイン分離とBoUser管理

## 背景・課題

### 現状の問題点

現在のシステムでは以下の問題があります：

1. **認証・認可の混在**
   - 顧客（Customer）と管理者（Admin）が同じ User テーブルで管理されている
   - Role enum で区別しているが、データモデルが混在している
   - 顧客情報と管理者情報が同じテーブルに存在することでセキュリティリスクがある

2. **ドメインの未分離**
   - 顧客向け画面（EC サイト）と管理画面が同じドメイン・ポート上で動作
   - 管理画面へのアクセス制御がアプリケーション層のみで行われている
   - 将来的なスケーラビリティや運用面での課題

3. **管理者特有のデータ管理ができない**
   - 管理者には顧客にない属性（権限レベル、最終ログイン日時など）が必要
   - User テーブルに顧客向けフィールドと管理者向けフィールドが混在する設計になりがち

### なぜ必要か

- **セキュリティ強化**: 顧客データと管理者データを物理的に分離し、漏洩リスクを低減
- **保守性向上**: ドメイン分離により、顧客向け機能と管理機能の独立したデプロイ・メンテナンスが可能に
- **スケーラビリティ**: 将来的に管理画面と顧客画面を異なるインフラで運用可能
- **明確な責務分離**: ビジネスドメインが明確に分かれることで、開発・運用の責任範囲が明確化

---

## ビジネス要件

### 1. ドメイン分離

#### 1.1 顧客画面（フロントオフィス）
- **目的**: 一般ユーザー向けのECサイト機能
- **アクセス**: 公開ドメイン（例: `https://example.com`）
- **機能範囲**:
  - 商品閲覧・購入
  - カート管理
  - 注文履歴
  - 会員登録・ログイン・マイページ

#### 1.2 管理画面（バックオフィス）
- **目的**: 管理者向けの業務管理機能
- **アクセス**: 管理者専用ドメイン（例: `https://admin.example.com` または異なるポート）
- **機能範囲**:
  - 商品管理
  - 注文管理
  - 在庫管理
  - 会員管理（顧客情報）
  - 管理者管理（BoUser）

### 2. BoUser（バックオフィスユーザー）の別テーブル管理

#### 2.1 テーブル分離
- **users テーブル**: 顧客（Customer）専用
- **bo_users テーブル**: 管理者（BackOffice User）専用

#### 2.2 管理者の属性
管理者には以下のような属性が必要：
- 基本情報: ID、メールアドレス、パスワード、表示名
- 管理者固有情報: 権限レベル、最終ログイン日時
- 監査情報: 作成日時、更新日時、有効/無効フラグ

#### 2.3 認証・認可の分離
- 顧客の認証: User テーブルを参照
- 管理者の認証: BoUser テーブルを参照
- トークンやセッションも別管理（異なるテーブルまたは prefix で区別）

---

## 受け入れ条件

### 必須要件

1. **ドメイン分離**
   - [ ] 顧客画面と管理画面が異なる URL またはポートでアクセス可能であること
   - [ ] 管理画面へのアクセスは BoUser の認証が必須であること
   - [ ] 顧客画面から管理画面へ直接アクセスできないこと

2. **BoUser テーブルの実装**
   - [ ] bo_users テーブルが新設され、管理者情報が格納されること
   - [ ] users テーブルには顧客情報のみが格納されること
   - [ ] 既存の管理者アカウント（User の Role=ADMIN）が BoUser に移行されること

3. **認証・認可の分離**
   - [ ] BoUser 用の認証エンドポイント（`/api/bo-auth/login` など）が実装されること
   - [ ] BoUser のトークンと User のトークンが別管理されること
   - [ ] 管理画面の API は BoUser の認証トークンのみを受け付けること

4. **既存機能の維持**
   - [ ] 顧客向け機能（商品閲覧、カート、注文）が引き続き動作すること
   - [ ] 管理画面の既存機能（注文管理、在庫管理、会員管理）が引き続き動作すること

5. **誤アクセス防止**
   - [ ] 顧客トークンで `/api/bo/**` にアクセスすると必ず 401/403 エラーになること
   - [ ] BoUser トークンで顧客用 API にアクセスした場合の挙動が明確であること
   - [ ] 権限チェックは Controller に散らさず、一箇所（Security Filter / Interceptor）に集約されること

6. **キャッシュ方針**
   - [ ] 管理 API は `Cache-Control: no-store` が設定されること
   - [ ] 同じ URL で admin/非 admin でレスポンスを変えないこと（URL パスで明確に分離）

7. **API エンドポイントの物理的分離**
   - [ ] 顧客向け API: `/api/**` （User 認証）
   - [ ] 管理者向け API: `/api/bo/**` （BoUser 認証のみ）
   - [ ] `/api/bo/**` には BoUser 認証フィルタが必ずかかること

### テスト項目（誤アクセス防止）

システムが正しく動作することを確認するため、以下のテストが必須：

1. **顧客トークンでの管理 API アクセス**
   - [ ] 顧客（User）トークンで `/api/bo/**` にアクセスすると **必ず 401 または 403** が返ること
   - [ ] エラーメッセージが適切であること（例: "管理者権限が必要です"）

2. **BoUser トークンでの顧客 API アクセス**
   - [ ] BoUser トークンで `/api/**`（顧客向け API）にアクセスした場合の挙動が明確であること
   - [ ] 基本方針: BoUser は顧客 API を叩ける（または叩けない）が、設計で明文化すること

3. **トークンなしでのアクセス**
   - [ ] 認証が必要なエンドポイントに認証なしでアクセスすると **401** が返ること

4. **トークン失効後のアクセス**
   - [ ] ログアウト後のトークンでアクセスすると **401** が返ること
   - [ ] 有効期限切れトークンでアクセスすると **401** が返ること

5. **キャッシュ制御**
   - [ ] 管理 API のレスポンスヘッダーに `Cache-Control: no-store` が含まれること
   - [ ] 顧客 API と管理 API で同じ URL が存在しないこと（URL パスで明確に分離）

### 任意要件（将来対応）

- [ ] BoUser の権限を RBAC（Role-Based Access Control）に拡張可能な設計
  - 現時点では権限レベル（シンプルな enum）で OK
  - 将来的に `bo_roles` / `bo_permissions` テーブルに拡張できる余地を残す
- [ ] BoUser の操作ログをより詳細に記録
- [ ] 管理画面の多要素認証（MFA）対応
- [ ] トークンのリフレッシュ機能（access token 短命 + refresh token 長命）

---

## 影響範囲

### データベース
- bo_users テーブルの新設
- bo_auth_tokens テーブルの新設（管理者認証トークン）
- users テーブルから Role 列の削除（顧客専用になるため）

### バックエンド
- BoUser エンティティ、リポジトリ、サービスの追加
- BoAuth コントローラーの追加（BoUser 認証用）
- 既存の Admin 系コントローラーを BoUser 認証に切り替え
- **API エンドポイントの再構成**:
  - 顧客向け: `/api/**` （User 認証）
  - 管理者向け: `/api/bo/**` （BoUser 認証）
- **認証フィルタの追加**:
  - `/api/bo/**` に対する BoUser 認証フィルタ
  - 顧客トークンでのアクセスを確実に拒否する仕組み

### フロントエンド
- 管理画面のベース URL 変更（環境変数対応）
- 管理画面の認証フローを BoAuth に切り替え
- 顧客画面は変更なし（既存の User 認証を継続）

### 運用
- 初期管理者アカウントのセットアップ手順
- 既存管理者の移行手順

---

## 非機能要件

### セキュリティ

#### 認証・認可
- BoUser のパスワードは bcrypt などで安全にハッシュ化されること
- 管理画面の認証トークンは顧客画面のトークンと混同されないこと
- 顧客情報へのアクセスは BoUser のみが可能であること

#### トークン設計
- **トークン保存**: `auth_tokens` / `bo_auth_tokens` は完全別テーブル
- **ハッシュ化**: 生トークンは保存せず、ハッシュ化して保存すること（User 側・BoUser 側ともに同様）
- **失効管理**: ログアウト時の失効、強制ログアウト機能が実装されること
- **有効期限**: トークンの有効期限が明確に設定されること（例: 24時間、7日間など）
- **クライアント保存**:
  - Bearer トークン運用の場合: `localStorage` または `sessionStorage` に保存
  - XSS 対策として、適切な Content-Security-Policy を設定すること

#### CORS / Cookie 方針
- **ドメイン跨ぎの考慮**: `admin.example.com` と `example.com` を跨ぐ場合の CORS 設定を明確にすること
- **Bearer トークン運用**（推奨）:
  - Authorization ヘッダーで送信
  - XSS 対策: CSP（Content-Security-Policy）の設定
  - HTTPS 必須
- **Cookie 運用の場合**（将来対応）:
  - `HttpOnly`, `Secure`, `SameSite=Strict` または `SameSite=Lax` の設定
  - CSRF 対策: Double Submit Cookie または CSRF トークン

#### API アクセス制御
- 権限チェックはアプリケーション層の一箇所（Security Filter / Interceptor）に集約すること
- Controller に認可ロジックを散らさないこと

### パフォーマンス
- ドメイン分離により、顧客画面のパフォーマンスが低下しないこと
- 管理 API は `Cache-Control: no-store` でキャッシュを無効化すること

### 保守性
- User と BoUser のコードが明確に分離されていること
- 将来的な拡張（RBAC への移行など）が容易であること
- 権限チェックロジックが一箇所に集約されていること

---

## 備考

### 段階的な移行戦略

この変更は既存の認証・認可システムに大きな影響を与えるため、以下の段階的な移行を推奨：

#### Phase 1: バックエンド基盤整備
1. `bo_users` / `bo_auth_tokens` テーブル作成
2. BoUser エンティティ、リポジトリ、サービス実装
3. `/api/bo-auth/**` 認証エンドポイント実装
4. BoUser 認証フィルタの実装

#### Phase 2: 管理 API の移行
1. 既存の `/api/admin/**` を `/api/bo/admin/**` に移行
2. AdminController → BoAdminController への切り替え
3. 既存の User Role=ADMIN を BoUser に移行するマイグレーションスクリプト作成

#### Phase 3: フロントエンド対応
1. 管理画面の認証フローを BoAuth に切り替え
2. API 呼び出しを `/api/bo/**` に変更
3. 環境変数で管理画面のベース URL を設定可能に

#### Phase 4: テスト・検証
1. 誤アクセス防止テストの実施
2. パフォーマンステスト
3. セキュリティ監査

### 注意事項

- **後方互換性**: 既存の顧客（User）の認証・認可は一切変更しない
- **データ移行**: 既存の管理者アカウント（User の Role=ADMIN）を BoUser に移行する際、データ損失がないこと
- **ロールバック**: 問題が発生した場合に備え、旧システムへのロールバック手順を用意すること
