# CHG-017: 非同期処理（監査ログ・メール送信）- 技術設計

要件: `docs/01_requirements/CHG-017_非同期処理要件定義.md`
作成日: 2026-02-18

---

## 1. 設計方針

### Transactional Outbox パターンを採用する理由

要件の「再試行可能・冪等性・DLQ相当余地」を `@Async + Spring Events` では満たせない。

| 要件 | @Async | Outbox |
|------|--------|--------|
| 再試行可能 | ✗（失敗したら消える） | ✓（DBに残るため再試行できる） |
| 冪等性（二重処理なし） | 保証困難 | ✓（status カラムで制御） |
| DLQ相当 | ✗ | ✓（DEAD ステータスで保持） |
| プロセス再起動でも失わない | ✗（メモリのみ） | ✓（DBに永続化済み） |
| 大規模MQ不要 | ✓ | ✓（DB のみで実現） |

> 要件 2.4「Kafka等の大規模メッセージ基盤の導入は非目標」はOutboxパターンと矛盾しない。OutboxはDBのみで実現できる。

### 基本原則

- **Atomic Write**: メイン処理と同一トランザクション内で `outbox_events` に書き込む。処理の成功と副作用イベントの発行が不可分になる
- **ポーリングワーカー**: `@Scheduled` ワーカーが `outbox_events` をポーリングし、各ハンドラへディスパッチする
- **再試行**: 失敗時は `retry_count` をインクリメントし `scheduled_at` を延長。`max_retries` 到達で `DEAD` に移行
- **冪等性**: `status` カラムの楽観的ロックで同一イベントの二重処理を防ぐ
- **DLQ相当**: `status = DEAD` のレコードを保持し、将来の手動再実行・調査を可能にする

### 監査ログの現行実装の課題と修正

現行の `OperationHistoryEventHandler` は `@EventListener`（同期）+ `REQUIRES_NEW` を使用している。これはメイン処理のコミット前にログを記録するため、**メイン処理失敗時でもログが残る**という問題がある（「成功操作のみ記録」要件違反）。

今回、監査ログもOutboxパターンに統一し、コミット後のみ記録されるよう修正する。

---

## 2. インフラ変更（docker-compose.yml）

Mailpit（SMTPキャッチャ）を追加する。

```yaml
# 追加するサービス
mailpit:
  image: axllent/mailpit:latest
  container_name: ec-mailpit
  ports:
    - "8025:8025"   # Web UI（ホスト公開）
    - "1025:1025"   # SMTP（内部のみでOKだが開発便宜上公開）
  networks:
    - public    # Web UI 公開
    - internal  # バックエンドからのSMTP接続
```

`backend` サービスの `depends_on` に `mailpit` を追加。

---

## 3. DBスキーマ変更（Flyway: V7）

`backend/src/main/resources/db/flyway/V7__add_outbox_events.sql`

```sql
CREATE TYPE outbox_event_status AS ENUM ('PENDING', 'PROCESSING', 'PROCESSED', 'DEAD');

CREATE TABLE outbox_events (
    id            BIGSERIAL PRIMARY KEY,
    event_type    VARCHAR(100)          NOT NULL,  -- 'ORDER_CONFIRMED', 'OPERATION_PERFORMED'
    aggregate_id  VARCHAR(255),                    -- 関連エンティティID（ログ・デバッグ用）
    payload       JSONB                 NOT NULL,  -- イベントデータ（JSON）
    status        outbox_event_status   NOT NULL DEFAULT 'PENDING',
    retry_count   INT                   NOT NULL DEFAULT 0,
    max_retries   INT                   NOT NULL DEFAULT 3,
    error_message TEXT,
    scheduled_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,  -- 次回処理予定
    processed_at  TIMESTAMP WITH TIME ZONE,
    created_at    TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ワーカーが PENDING レコードを高速取得するためのインデックス
CREATE INDEX idx_outbox_events_status_scheduled
    ON outbox_events (status, scheduled_at)
    WHERE status = 'PENDING';
```

---

## 4. バックエンド実装

### 4.1 依存ライブラリ追加（pom.xml）

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

### 4.2 application.yml 設定追加

```yaml
# デフォルトプロファイル（開発環境）
spring:
  mail:
    host: ${MAIL_HOST:localhost}
    port: ${MAIL_PORT:1025}
    properties:
      mail:
        smtp:
          auth: false
          starttls:
            enable: false

---
# production-internal プロファイル
spring:
  mail:
    host: mailpit
    port: 1025
    properties:
      mail:
        smtp:
          auth: false
          starttls:
            enable: false
```

### 4.3 パッケージ構成（新規ファイル）

```
backend/src/main/java/com/example/aiec/
├── modules/
│   └── shared/
│       ├── event/
│       │   ├── DomainEvent.java                          (既存)
│       │   └── OperationPerformedEvent.java              (既存)
│       └── outbox/
│           ├── domain/
│           │   ├── entity/OutboxEvent.java               [新規] エンティティ
│           │   └── repository/OutboxEventRepository.java [新規] リポジトリ
│           ├── application/
│           │   ├── OutboxEventPublisher.java             [新規] 書き込み（Port）
│           │   └── OutboxProcessor.java                  [新規] ポーリングワーカー
│           └── handler/
│               ├── OutboxEventHandler.java               [新規] ハンドラインターフェース
│               ├── EmailOutboxHandler.java               [新規] メール送信
│               └── AuditLogOutboxHandler.java            [新規] 監査ログ記録
└── modules/
    └── purchase/
        └── application/
            └── usecase/
                └── OrderUseCase.java                     [変更] Outbox書き込み追加
```

### 4.4 OutboxEvent エンティティ

`modules/shared/outbox/domain/entity/OutboxEvent.java`

```java
package com.example.aiec.modules.shared.outbox.domain.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "outbox_events")
@Data
@NoArgsConstructor
public class OutboxEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "event_type", nullable = false, length = 100)
    private String eventType;

    @Column(name = "aggregate_id", length = 255)
    private String aggregateId;

    @Column(nullable = false, columnDefinition = "JSONB")
    private String payload;  // JSON文字列

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OutboxStatus status = OutboxStatus.PENDING;

    @Column(name = "retry_count", nullable = false)
    private int retryCount = 0;

    @Column(name = "max_retries", nullable = false)
    private int maxRetries = 3;

    @Column(name = "error_message")
    private String errorMessage;

    @Column(name = "scheduled_at", nullable = false)
    private Instant scheduledAt = Instant.now();

    @Column(name = "processed_at")
    private Instant processedAt;

    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = Instant.now();
    }

    public enum OutboxStatus {
        PENDING, PROCESSING, PROCESSED, DEAD
    }

    public static OutboxEvent create(String eventType, String aggregateId, String payload) {
        OutboxEvent e = new OutboxEvent();
        e.eventType = eventType;
        e.aggregateId = aggregateId;
        e.payload = payload;
        return e;
    }
}
```

### 4.5 OutboxEventRepository

`modules/shared/outbox/domain/repository/OutboxEventRepository.java`

```java
package com.example.aiec.modules.shared.outbox.domain.repository;

import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.time.Instant;
import java.util.List;

public interface OutboxEventRepository extends JpaRepository<OutboxEvent, Long> {

    @Query("""
        SELECT e FROM OutboxEvent e
        WHERE e.status = 'PENDING'
          AND e.scheduledAt <= :now
        ORDER BY e.scheduledAt ASC
        LIMIT 50
        """)
    List<OutboxEvent> findPendingEvents(Instant now);
}
```

### 4.6 OutboxEventPublisher（書き込みサービス）

`modules/shared/outbox/application/OutboxEventPublisher.java`

```java
package com.example.aiec.modules.shared.outbox.application;

import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
import com.example.aiec.modules.shared.outbox.domain.repository.OutboxEventRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.stereotype.Service;

/**
 * Outboxへのイベント書き込みサービス。
 * 呼び出し元のトランザクション内で実行されるため、メイン処理と同一トランザクションに参加する。
 */
@Service
@RequiredArgsConstructor
public class OutboxEventPublisher {

    private final OutboxEventRepository outboxEventRepository;
    private final ObjectMapper objectMapper;

    @SneakyThrows
    public void publish(String eventType, String aggregateId, Object payloadObject) {
        String payload = objectMapper.writeValueAsString(payloadObject);
        OutboxEvent event = OutboxEvent.create(eventType, aggregateId, payload);
        outboxEventRepository.save(event);
    }
}
```

### 4.7 OutboxEventHandler インターフェース

`modules/shared/outbox/handler/OutboxEventHandler.java`

```java
package com.example.aiec.modules.shared.outbox.handler;

import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;

public interface OutboxEventHandler {
    String getSupportedEventType();
    void handle(OutboxEvent event) throws Exception;
}
```

### 4.8 OutboxProcessor（ポーリングワーカー）

`modules/shared/outbox/application/OutboxProcessor.java`

```java
package com.example.aiec.modules.shared.outbox.application;

import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent.OutboxStatus;
import com.example.aiec.modules.shared.outbox.domain.repository.OutboxEventRepository;
import com.example.aiec.modules.shared.outbox.handler.OutboxEventHandler;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Outboxイベントポーリングワーカー。
 *
 * - 5秒ごとに PENDING イベントを最大50件取得してディスパッチする
 * - 成功: PROCESSED に遷移
 * - 失敗: retry_count インクリメント。max_retries 到達で DEAD に遷移
 * - 各イベントを個別トランザクションで処理（1件の失敗が他に波及しない）
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OutboxProcessor {

    private final OutboxEventRepository outboxEventRepository;
    private final Map<String, OutboxEventHandler> handlerMap;

    // ハンドラ一覧を DI で受け取り、event_type → handler のマップを構築
    public OutboxProcessor(
            OutboxEventRepository outboxEventRepository,
            List<OutboxEventHandler> handlers) {
        this.outboxEventRepository = outboxEventRepository;
        this.handlerMap = handlers.stream()
                .collect(Collectors.toMap(
                        OutboxEventHandler::getSupportedEventType,
                        Function.identity()
                ));
    }

    @Scheduled(fixedDelay = 5000)
    public void process() {
        List<OutboxEvent> events = outboxEventRepository.findPendingEvents(Instant.now());
        for (OutboxEvent event : events) {
            processOne(event);
        }
    }

    @Transactional
    public void processOne(OutboxEvent event) {
        // 楽観的ロック相当: PENDING → PROCESSING に変更してから処理
        event.setStatus(OutboxStatus.PROCESSING);
        outboxEventRepository.save(event);

        OutboxEventHandler handler = handlerMap.get(event.getEventType());
        if (handler == null) {
            log.warn("未知のイベントタイプ: {}", event.getEventType());
            event.setStatus(OutboxStatus.DEAD);
            event.setErrorMessage("No handler for event type: " + event.getEventType());
            outboxEventRepository.save(event);
            return;
        }

        try {
            handler.handle(event);
            event.setStatus(OutboxStatus.PROCESSED);
            event.setProcessedAt(Instant.now());
            log.info("Outboxイベント処理完了: id={}, type={}", event.getId(), event.getEventType());
        } catch (Exception e) {
            int newRetryCount = event.getRetryCount() + 1;
            event.setRetryCount(newRetryCount);
            event.setErrorMessage(e.getMessage());

            if (newRetryCount >= event.getMaxRetries()) {
                event.setStatus(OutboxStatus.DEAD);
                log.error("Outboxイベント最大リトライ到達（DEAD）: id={}, type={}",
                        event.getId(), event.getEventType(), e);
            } else {
                // 指数バックオフ（30s, 60s, 120s ...）
                event.setStatus(OutboxStatus.PENDING);
                event.setScheduledAt(Instant.now().plusSeconds(30L * newRetryCount));
                log.warn("Outboxイベント再試行スケジュール: id={}, type={}, retryCount={}/{}",
                        event.getId(), event.getEventType(), newRetryCount, event.getMaxRetries(), e);
            }
        }
        outboxEventRepository.save(event);
    }
}
```

### 4.9 EmailOutboxHandler（メール送信ハンドラ）

`modules/shared/outbox/handler/EmailOutboxHandler.java`

```java
package com.example.aiec.modules.shared.outbox.handler;

import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Component;

/**
 * ORDER_CONFIRMED イベントの処理ハンドラ（注文確認メール送信）。
 * ゲスト注文（customerEmail が null）はスキップ。
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class EmailOutboxHandler implements OutboxEventHandler {

    private final JavaMailSender mailSender;
    private final ObjectMapper objectMapper;

    @Override
    public String getSupportedEventType() {
        return "ORDER_CONFIRMED";
    }

    @Override
    public void handle(OutboxEvent event) throws Exception {
        JsonNode payload = objectMapper.readTree(event.getPayload());
        String customerEmail = payload.path("customerEmail").asText(null);

        if (customerEmail == null || customerEmail.isBlank()) {
            log.debug("ゲスト注文のためメール送信スキップ: outboxId={}", event.getId());
            return;
        }

        String orderNumber = payload.path("orderNumber").asText();
        String totalPrice  = payload.path("totalPrice").asText();

        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(customerEmail);
        message.setSubject("ご注文確認 - " + orderNumber);
        message.setText("""
            ご注文ありがとうございます。
            注文番号: %s
            合計金額: ¥%s
            """.formatted(orderNumber, totalPrice));

        mailSender.send(message);
        log.info("注文確認メール送信完了: outboxId={}, to={}", event.getId(), customerEmail);
    }
}
```

### 4.10 AuditLogOutboxHandler（監査ログハンドラ）

`modules/shared/outbox/handler/AuditLogOutboxHandler.java`

```java
package com.example.aiec.modules.shared.outbox.handler;

import com.example.aiec.modules.shared.domain.entity.OperationHistory;
import com.example.aiec.modules.shared.domain.repository.OperationHistoryRepository;
import com.example.aiec.modules.shared.outbox.domain.entity.OutboxEvent;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * OPERATION_PERFORMED イベントの処理ハンドラ（監査ログ記録）。
 * OutboxProcessor の processOne() とは別トランザクション（REQUIRES_NEW）で実行し、
 * 監査ログ記録の失敗をイベントステータスの更新から分離する。
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class AuditLogOutboxHandler implements OutboxEventHandler {

    private final OperationHistoryRepository operationHistoryRepository;
    private final ObjectMapper objectMapper;

    @Override
    public String getSupportedEventType() {
        return "OPERATION_PERFORMED";
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void handle(OutboxEvent event) throws Exception {
        JsonNode payload = objectMapper.readTree(event.getPayload());

        OperationHistory history = new OperationHistory();
        history.setOperationType(payload.path("operationType").asText());
        history.setPerformedBy(payload.path("performedBy").asText());
        history.setRequestPath(payload.path("requestPath").asText());
        history.setDetails(payload.path("details").asText());

        operationHistoryRepository.save(history);
        log.debug("監査ログ記録完了: outboxId={}, type={}", event.getId(), history.getOperationType());
    }
}
```

### 4.11 既存コードの変更

#### OrderUseCase（confirmOrder にOutbox書き込み追加）

```java
// 追加フィールド
private final OutboxEventPublisher outboxEventPublisher;

// 変更後: confirmOrder
@Override
@Transactional(rollbackFor = Exception.class)
public OrderDto confirmOrder(Long orderId) {
    Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new ResourceNotFoundException("ORDER_NOT_FOUND", "注文が見つかりません"));

    if (order.getStatus() != Order.OrderStatus.PENDING) {
        throw new BusinessException("INVALID_STATUS_TRANSITION",
            "この注文は確認できません（現在のステータス: " + order.getStatus() + "）");
    }

    order.setStatus(Order.OrderStatus.CONFIRMED);
    order = orderRepository.save(order);

    // 同一トランザクションでOutboxに書き込む（コミット成功時のみイベントが残る）
    outboxEventPublisher.publish("ORDER_CONFIRMED", String.valueOf(order.getId()), Map.of(
        "orderId", order.getId(),
        "orderNumber", order.getOrderNumber(),
        "customerEmail", order.getUser() != null ? order.getUser().getEmail() : null,
        "totalPrice", order.getTotalPrice()
    ));

    return OrderDto.fromEntity(order);
}
```

#### OperationHistoryEventHandler（Outboxへ移行）

現行の `OperationHistoryEventHandler` は `AuditLogOutboxHandler` に役割を移譲するため**削除**する。

`OperationPerformedEvent` の発行箇所（各コントローラ等）は、`publishEvent()` の代わりに `OutboxEventPublisher.publish("OPERATION_PERFORMED", ...)` に書き換える。

---

## 5. 処理フロー

### 注文確定フロー

```
管理画面          BackOffice BFF       Core API
    │                  │                  │
    │ POST /order/{id}/confirm            │
    │─────────────────>│                  │
    │                  │─────────────────>│
    │                  │                  │ [Tx 開始]
    │                  │                  │  orders.status = CONFIRMED
    │                  │                  │  outbox_events (PENDING) を INSERT
    │                  │                  │ [Tx コミット ← ここで不可分確定]
    │                  │  200 OK          │
    │                  │<─────────────────│
    │   200 OK         │                  │
    │<─────────────────│                  │
    │                  │                  │
    │                  │                  │ [OutboxProcessor @Scheduled 5s後]
    │                  │                  │  PENDING → PROCESSING
    │                  │                  │  EmailOutboxHandler.handle()
    │                  │                  │   → JavaMailSender → Mailpit
    │                  │                  │  PROCESSING → PROCESSED
    │                  │                  │
    │                  │                  │  失敗時: retry_count++ → scheduled_at 延長
    │                  │                  │  3回失敗: DEAD（DLQ相当）
```

### 再試行フロー

```
outbox_events テーブル

id | event_type      | status     | retry_count | scheduled_at
---+-----------------+------------+-------------+-------------------
1  | ORDER_CONFIRMED | PENDING    | 0           | 2026-02-18 10:00:00  ← 初回
1  | ORDER_CONFIRMED | PENDING    | 1           | 2026-02-18 10:00:30  ← 1回失敗後(+30s)
1  | ORDER_CONFIRMED | PENDING    | 2           | 2026-02-18 10:01:00  ← 2回失敗後(+60s)
1  | ORDER_CONFIRMED | DEAD       | 3           | ─                    ← DLQ
```

---

## 6. テスト観点

| テストケース | 確認方法 |
|-------------|---------|
| 注文確定 → Outboxに PENDING レコード作成 | DB確認: `SELECT * FROM outbox_events WHERE status='PENDING'` |
| OutboxProcessor → PROCESSED に遷移 | 5秒後にレコードの status が PROCESSED になること |
| 注文確定 → 会員宛メール送信 | Mailpit Web UI (http://localhost:8025) で受信確認 |
| ゲスト注文確定 → メール送信スキップ | ゲスト注文確定後、Mailpit に届かないこと。Outbox は PROCESSED |
| SMTP障害時 → DEAD に遷移（3回後） | Mailpit を停止した状態で注文確定。3回失敗後 status = DEAD |
| SMTP障害時 → 注文は確定済みのまま | orders テーブルの status は CONFIRMED のまま |
| Outboxの冪等性 | PROCESSING 中に再起動しても二重送信されないこと |
| 監査ログ → 成功操作のみ記録 | メイン処理をロールバックさせた場合、outbox_events に残らないこと |

---

## 7. 影響範囲

### 変更・新規作成ファイル

| ファイル | 変更種別 | 内容 |
|---------|---------|------|
| `docker-compose.yml` | 変更 | Mailpit サービス追加 |
| `backend/pom.xml` | 変更 | `spring-boot-starter-mail` 追加 |
| `backend/src/main/resources/application.yml` | 変更 | Spring Mail 設定追加 |
| `db/flyway/V7__add_outbox_events.sql` | 新規 | `outbox_events` テーブル作成 |
| `shared/outbox/domain/entity/OutboxEvent.java` | 新規 | Outboxエンティティ |
| `shared/outbox/domain/repository/OutboxEventRepository.java` | 新規 | リポジトリ |
| `shared/outbox/application/OutboxEventPublisher.java` | 新規 | 書き込みサービス |
| `shared/outbox/application/OutboxProcessor.java` | 新規 | ポーリングワーカー |
| `shared/outbox/handler/OutboxEventHandler.java` | 新規 | ハンドラIF |
| `shared/outbox/handler/EmailOutboxHandler.java` | 新規 | メール送信 |
| `shared/outbox/handler/AuditLogOutboxHandler.java` | 新規 | 監査ログ記録 |
| `purchase/application/usecase/OrderUseCase.java` | 変更 | confirmOrder にOutbox書き込み追加 |
| `shared/application/usecase/OperationHistoryEventHandler.java` | **削除** | AuditLogOutboxHandler に移行 |
| 各コントローラ（`publishEvent` 呼び出し箇所） | 変更 | `OutboxEventPublisher.publish()` に置き換え |

### 影響なし

- フロントエンド（顧客画面・管理画面）: API レスポンス仕様に変更なし
- BFF (Customer / BackOffice): エンドポイント変更なし
- `SchedulingConfig.java`: `@EnableScheduling` は既存のまま使用

---

## 8. 設計上の制約・注意事項

### PROCESSING 状態の残留（ゾンビ問題）

`OutboxProcessor.processOne()` の途中でJVMがクラッシュした場合、レコードが `PROCESSING` のまま残る。対策として、次のタスクで「`PROCESSING` かつ `scheduled_at` が一定時間（例: 10分）以上前のものを `PENDING` に戻す」ハウスキーピング処理を追加することを推奨する（今回は対象外）。

### OutboxProcessor の多重起動

水平スケールアウト時、複数のインスタンスが同じレコードを同時に取得する可能性がある。今回は単一インスタンス構成のため問題なし。将来的にはSELECT FOR UPDATE SKIP LOCKED を使用するクエリに変更する。

### ArchUnit 境界制約への適合

`outbox` サブパッケージは `shared` モジュール内に配置するため、他モジュールの `domain.*` を直接参照しない。`EmailOutboxHandler` は注文情報を JSON ペイロードから取得するため、purchase モジュールへの依存なし。
